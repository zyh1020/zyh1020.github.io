"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[7993],{9562:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>o,data:()=>p});var i=a(641);const l={},o=(0,a(6262).A)(l,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h3 id="一-jvm运行时内存划分" tabindex="-1"><a class="header-anchor" href="#一-jvm运行时内存划分"><span>一，JVM运行时内存划分</span></a></h3><img src="http://img.zouyh.top/article-img/20240917135026220.png" alt="image-20230207104425346" style="zoom:67%;"><p>线程共享区：</p><ul><li>方法堆</li><li>java堆</li></ul><p>线程独占区：</p><ul><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数区</li></ul><h4 id="_1-1-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_1-1-虚拟机栈"><span>1.1 虚拟机栈</span></a></h4><ul><li>虚拟机栈描述的是Java方法执行的动态内存模型；</li><li>栈帧：每一个方法的执行都会创建一个栈帧，伴随着方法从创建（压入虚拟机栈）到执行完成（弹出虚拟机栈）。用于存储局部变量表，操作数栈，动态链接，方法出口等。栈帧包含一个方法的主要信息。</li><li>局部变量表：存放编译期可知的各种基本数据类型，引用类型，方法的出口地址；局部变量表的内存空间，在编译期完成分配，当进入一个方法时，这个方法，需要在帧中分配的空间时固定的，在方法运行期间不会改变局部变量表的大小。</li><li>StackOverFlowError：通常是递归调用方法不合理，导致虚拟机栈空间不够了</li></ul><h4 id="_1-2-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_1-2-本地方法栈"><span>1.2 本地方法栈</span></a></h4><p>在hotspot中，虚拟机栈和本地方法栈是同一块区域；</p><img src="http://img.zouyh.top/article-img/20240917135026222.png" alt="image-20230207104901311" style="zoom:80%;"><p>虚拟机栈和本地方法栈区别：</p><ul><li>虚拟机栈是为虚拟机执行java方法服务的；</li><li>本地方法栈是为虚拟机执行native方法服务的；</li></ul><h4 id="_1-3-程序计数区" tabindex="-1"><a class="header-anchor" href="#_1-3-程序计数区"><span>1.3 程序计数区</span></a></h4><ul><li>程序计数器是一个比较小的内存空间，可以将其看作是当前线程锁执行的字节码的行号指示器。</li><li>程序计数器位于线程独占区</li><li>此区域是唯一没有OutOfMemroyError（内存溢出错误）错误的区域</li></ul><h4 id="_1-4-堆" tabindex="-1"><a class="header-anchor" href="#_1-4-堆"><span>1.4 堆</span></a></h4><p>Java中堆内存划分：</p><img src="http://img.zouyh.top/article-img/20240917135026221.png" alt="image-20230207105158020" style="zoom:50%;"><p>在整个JVM的堆内存中实际上将内存分为了三部分：</p><ul><li><p>新生代</p><p>​ 新生代几乎是所有Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕死的性质，新生代是 GC 收集垃圾的频繁区域。新生代分为三个区：Eden 和 两个存活区（From 和 To），默认分别占内存的80%、10%、10% ，可以通过参数<code>–XX:SurvivorRatio</code> 来设定 。</p><blockquote><p>注： JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p></blockquote></li><li><p>老年代</p></li></ul><p>​ 存储被长时间使用的对象， 默认新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，该值可以通过参数 <code>–XX:NewRatio </code>来指定.</p><ul><li><p>元空间（JDK1.8之前叫永久代）</p><p>​ 存储一些方法中操作的临时对象等，JKD1.8之前是占用JVM内存，JDK1.8之后直接占用物理内存。取消永久代的目的是将 HotSpot和JRockit 的两个虚拟机标注联合为一个。</p></li></ul><h4 id="_1-5-方法区" tabindex="-1"><a class="header-anchor" href="#_1-5-方法区"><span>1.5 方法区</span></a></h4><p>​ 方法区主要存储已经被虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等数据。</p>',24)]))}]]),p=JSON.parse('{"path":"/blog/Jvm/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.html","title":"JVM运行时内存划分","lang":"zh-CN","frontmatter":{"icon":"file-lines","title":"JVM运行时内存划分","author":"Ms.Zyh","date":"2023-08-10T00:00:00.000Z","category":["Jvm"],"tag":["常用","Jvm"],"sticky":false,"star":false,"description":"一，JVM运行时内存划分 image-20230207104425346 线程共享区： 方法堆 java堆 线程独占区： 虚拟机栈 本地方法栈 程序计数区 1.1 虚拟机栈 虚拟机栈描述的是Java方法执行的动态内存模型； 栈帧：每一个方法的执行都会创建一个栈帧，伴随着方法从创建（压入虚拟机栈）到执行完成（弹出虚拟机栈）。用于存储局部变量表，操作数栈，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM运行时内存划分\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-20T07:21:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ms.Zyh\\"}]}"],["meta",{"property":"og:url","content":"http://img.zouyh.top/blog/Jvm/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.html"}],["meta",{"property":"og:site_name","content":"Mr.Zyh"}],["meta",{"property":"og:title","content":"JVM运行时内存划分"}],["meta",{"property":"og:description","content":"一，JVM运行时内存划分 image-20230207104425346 线程共享区： 方法堆 java堆 线程独占区： 虚拟机栈 本地方法栈 程序计数区 1.1 虚拟机栈 虚拟机栈描述的是Java方法执行的动态内存模型； 栈帧：每一个方法的执行都会创建一个栈帧，伴随着方法从创建（压入虚拟机栈）到执行完成（弹出虚拟机栈）。用于存储局部变量表，操作数栈，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-20T07:21:23.000Z"}],["meta",{"property":"article:author","content":"Ms.Zyh"}],["meta",{"property":"article:tag","content":"Jvm"}],["meta",{"property":"article:tag","content":"常用"}],["meta",{"property":"article:published_time","content":"2023-08-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-20T07:21:23.000Z"}]]},"git":{"createdTime":1755935409000,"updatedTime":1758352883000,"contributors":[{"name":"zyh1020","username":"zyh1020","email":"898362059@qq.pcom","commits":3,"url":"https://github.com/zyh1020"}]},"readingTime":{"minutes":2.84,"words":852},"filePathRelative":"blog/Jvm/JVM运行时内存划分.md","excerpt":"<h3>一，JVM运行时内存划分</h3>\\n<img src=\\"http://img.zouyh.top/article-img/20240917135026220.png\\" alt=\\"image-20230207104425346\\" style=\\"zoom: 67%;\\">\\n<p>线程共享区：</p>\\n<ul>\\n<li>方法堆</li>\\n<li>java堆</li>\\n</ul>\\n<p>线程独占区：</p>\\n<ul>\\n<li>虚拟机栈</li>\\n<li>本地方法栈</li>\\n<li>程序计数区</li>\\n</ul>\\n<h4>1.1 虚拟机栈</h4>\\n<ul>\\n<li>虚拟机栈描述的是Java方法执行的动态内存模型；</li>\\n<li>栈帧：每一个方法的执行都会创建一个栈帧，伴随着方法从创建（压入虚拟机栈）到执行完成（弹出虚拟机栈）。用于存储局部变量表，操作数栈，动态链接，方法出口等。栈帧包含一个方法的主要信息。</li>\\n<li>局部变量表：存放编译期可知的各种基本数据类型，引用类型，方法的出口地址；局部变量表的内存空间，在编译期完成分配，当进入一个方法时，这个方法，需要在帧中分配的空间时固定的，在方法运行期间不会改变局部变量表的大小。</li>\\n<li>StackOverFlowError：通常是递归调用方法不合理，导致虚拟机栈空间不够了</li>\\n</ul>","autoDesc":true}')}}]);