"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[6988],{4897:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>h});var l=a(641);const n={},t=(0,a(6262).A)(n,[["render",function(i,s){return(0,l.uX)(),(0,l.CE)("div",null,s[0]||(s[0]=[(0,l.Fv)('<p>数据类型和对应的数据结构：</p><table><thead><tr><th>数据类型</th><th>底层结构</th></tr></thead><tbody><tr><td>String</td><td>SDS</td></tr><tr><td>List</td><td>双向列表，压缩列表</td></tr><tr><td>Hash</td><td>压缩列表，Hash表</td></tr><tr><td>Set</td><td>整数集合，Hash表</td></tr><tr><td>SortedSet</td><td>压缩列表，跳表</td></tr></tbody></table><h3 id="一-string" tabindex="-1"><a class="header-anchor" href="#一-string"><span>一，String</span></a></h3><h4 id="_1-1-常见命令" tabindex="-1"><a class="header-anchor" href="#_1-1-常见命令"><span>1.1 常见命令</span></a></h4><p>redis的键是String类型：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看当前库中的所有key</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">keys</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> *</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看key是否存在</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">exists</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看key的类型</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">type</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看key对应值的底层编码</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">object</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> encoding</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除指定的key</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">del</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 非阻塞删除key的value</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlink</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 设置过期时间</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">expire</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 时间【单位</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 秒】</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看还有多少秒过期，-1表示永不过期；-2表示已经过期；</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ttl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看key的数量</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dbsize</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 清空当前库</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">flushdb</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 通杀全部库</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">flushall</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>redis的值是String类型：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 存储</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 设置多个值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mset</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ...</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 存储的时候设置过期时间</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setex</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 过期时间【单位</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 秒】</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取多个值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mget</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取value的部分值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getrange</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 起始位置</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 结束位置</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取原来的，并放置一个新的</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getset</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 存在不增加，不存在添加</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 数值递增</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">incr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 数值递增，并指定步长</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">incrby</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> increment</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 数值递减</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">decr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 数值递减，并指定步长：</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">decrby</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> decrement</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 向尾部追加值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取字符串长度</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">strlen</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_1-2-应用场景"><span>1.2 应用场景</span></a></h4><ul><li>缓存对象：直接缓存整个对象的 JSON 或者 采用将 key 进行分离为 <code>user:ID:</code>属性</li><li>常规计数: Redis 处理命令是单线程，所以执行命令的过程是原子或者使用lua脚本执行多条命令也是原子的，因此适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</li><li>分布式锁：可以用它来实现分布式锁。</li><li>共享 Session 信息：将Session ID作为key。</li></ul><h4 id="_1-3-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-3-数据结构"><span>1.3 数据结构</span></a></h4><p>redis 中所有的 key 都是字符串，这些字符串是通过一个名为简单动态字符串 SDS 的数据结构实现的。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sdshdr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // SDS header，[?] 可以为 8, 16, 32, 64</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uint?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_t len;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // 已用空间，字符串的实际长度</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uint?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_t alloc;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 已分配空间，不包含&#39;\\0&#39;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> flags;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 类型标记，指明了 len 与 alloc 的实际类型，可以通过 sds[-1] 获取</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> buf</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           // 字符数组，保存以&#39;\\0&#39;结尾的字符串，与传统 C 语言中的字符串的表达方式保持一致</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存布局如下：</p><img src="http://img.zouyh.top/article-img/20240917135015194.png" alt="image-20230306142129744" style="zoom:80%;"><p>​ 如果通过<code>append key value</code>向字符串追加值，可以通过 <code>alloc - len</code>计算出剩余的空间大小，用来判断空间是否可以存放，如果不满足的话，就会自动进行扩容，扩容的空间一般要高于实际所需空间，采用预分配冗余空间的方式来减少内存的频繁分配。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h3 id="二-list" tabindex="-1"><a class="header-anchor" href="#二-list"><span>二，List</span></a></h3><h4 id="_2-1-常见命令" tabindex="-1"><a class="header-anchor" href="#_2-1-常见命令"><span>2.1 常见命令</span></a></h4><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 从左边或右边插入值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lpush/rpush</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value3</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> .....</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 从左边或右边取出一个值，取出的值就不在list中</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lpop/rpop</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 从key1List右边取值，取出的值添加到key2List左边</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">rpoplpush</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 从下标为index，取len长度的值。  index = 0 len = -1表示查询所有</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lrange</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> index</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> len</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 取某个下标值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lindex</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> index</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取列表的长度</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">llen</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 在某个值value的前面或后面插入新值newvalue</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">linsert</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> before/afert</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> newvalue</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 表示删除左边len个值为value的数据</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lrem</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> len</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将下标为index的值替换为newvalue</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lset</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> index</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> newvalue</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_2-2-应用场景"><span>2.2 应用场景</span></a></h4><ul><li>队列：按先进先出的顺序对数据进行存取的，从左边或右边插入值<code>lpush/rpush</code>，然后从右边或左边取值<code>rpop/lpop</code>，使用<code>brpop</code>命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。缺点是List 不支持多个消费者消费同一条消息，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</li><li>栈：按先进后出的顺序对数据进行存取的，这样就可以实现如我们关注了订阅号，当点开订阅号消息时，订阅号都会显示最近发表的前1~4条文章，后发表的文章先出现</li></ul><h4 id="_2-3-数据结构" tabindex="-1"><a class="header-anchor" href="#_2-3-数据结构"><span>2.3 数据结构</span></a></h4><h5 id="_2-3-1-双向链表linkedlist" tabindex="-1"><a class="header-anchor" href="#_2-3-1-双向链表linkedlist"><span>2.3.1 双向链表LinkedList</span></a></h5><p>双向链表LinkedList的数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> list {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    listNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">head;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 链表头节点</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    listNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">tail;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 链表尾节点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">dup)(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ptr);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 节点值复制函数</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">free)(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ptr);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 节点值释放函数</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">match)(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ptr, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">key);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 节点值比较函数</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> len;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 链表节点数量</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} list;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>链表节点的数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listNode {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">prev;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 前置节点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">next;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 后置节点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">value;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           // 节点值</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} listNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存布局如下：</p><img src="http://img.zouyh.top/article-img/20240917135014190.png" alt="image-20230306144726943" style="zoom:80%;"><p>链表最大的优点就是维护起来比较简单，缺点是链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存，还有一点，就是内存开销较大，因此Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><h5 id="_2-3-2-压缩列表ziplist" tabindex="-1"><a class="header-anchor" href="#_2-3-2-压缩列表ziplist"><span>2.3.2 压缩列表zipList</span></a></h5><p>压缩列表zipList的数据结构:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">typedf </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ziplist</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int32 zlbytes;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 压缩列表占用字符数</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int32 zltail_offset;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 最后一个元素距离起始位置的偏移量，用于快速定位最后一个节点</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int16 zllength;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 元素个数</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> entries;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 元素内容entry</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int8 zlend;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 结束位 0xFF</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}ziplist</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是entry的数据结构:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">typede </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> entry{</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">var</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> prelen;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 前一个entry的长度</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">var</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> encoding;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 元素类型编码</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    optional byte</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> content;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 元素内容</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}entry</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存布局如下：</p><img src="http://img.zouyh.top/article-img/20240917135013187.png" alt="image-20230306152843403" style="zoom:80%;"><p><strong>连锁更新</strong></p><p>entry中有一个prelen字段，它的长度要么是1个字节，要么都是5个字节：</p><ul><li>前一个节点的长度小于254个字节，则prelen长度为1字节；</li><li>前一个节点的长度大于254字节，则prelen长度为5字节；</li></ul><p>​ 假设现在有一组压缩列表，entry的长度都在250<sub>253字节之间，现在突然新增一个entry节点，这个entry节点长度大于254字节。由于新的entry节点大于等于254字节，这个新增entry节点后面entry的prelen就变成为5个字节，而他本身就是在250</sub>253字节之间，当entry的prelen就变成为5个字节，必定会超过254个节点，那随后会导致其余的所有entry节点的prelen增大为5字节。</p><p>示意图如下所示：</p><img src="http://img.zouyh.top/article-img/20240917135013188.png" alt="image-20230306154239686" style="zoom:80%;"><p>同样地，删除操作也会导致出现连锁更新这种情况。</p><p>双向链表和压缩列表对比：</p><ul><li>双向链表LinkedList便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还有额外保存两个指针；其次，双向链表的各个节点都是单独的内存块，地址不连续，容易形成内存碎片</li><li>zipList存储在一块连续的内存上，所以存储效率很高。但是它不利于修改操作，插入和删除操作需要频繁地申请和释放内存。特别是当zipList长度很长时，一次realloc可能会导致大量的数据拷贝</li></ul><h5 id="_2-3-3-快速列表-quicklist" tabindex="-1"><a class="header-anchor" href="#_2-3-3-快速列表-quicklist"><span>2.3.3 快速列表 quickList</span></a></h5><p>在Redis3.2版本之后，list的底层实现方式又多了一种，quickList。qucikList是由zipList和双向链表linkedList组成的混合体。它将linkedList按段切分，单个节点使用zipList来紧凑存储，多个zipList之间使用双向指针串接起来。</p><p>qucikList的数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">typedf </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> quicklist{</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    quicklistNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> head;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向头结点</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    quicklistNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tail;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向尾节点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> count;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 元素总数</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nodes;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // quicklistNode节点的个数</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> compressDepth;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 压缩算法深度\t\t</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}quickList</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>quicklistNode的数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">typedf </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> quicklistNode{</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    quicklistNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> prev;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 前一个节点</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    quicklistNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> next;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 后一个节点</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ziplist</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zl;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 压缩列表\t</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int32 size;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">\t// ziplist大小\t</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int16 count;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // ziplist 中元素数量</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    int2 encoding;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 编码形式 存储 ziplist 还是进行 LZF 压缩储存的zipList\t</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}quickListNode</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示意图如下所示：</p><figure><img src="http://img.zouyh.top/article-img/20240917135015195.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>打开redis.conf文件:</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># quickList中每个ziplist节点可以存储多个元素,quickList内部默认单个zipList长度为8k字节，即list-max-ziplist-size为 -2，超出了这个阈值，就会重新生成一个zipList来存储数据。性能最好的时候就是就是list-max-ziplist-size为-1和-2，即分别是4kb和8kb的时候，当然，这个值也可以被设置为正数，当list-max-ziplist-szie为正数n时，表示每个quickList节点上的zipList最多包含n个数据项</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">list-max-ziplist-size -2</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 压缩深度,quickList中可以使用压缩算法对zipList进行进一步的压缩，这个算法就是LZF算法，这是一种无损压缩算法,list-compress-depth这个参数表示一个quickList两端不被压缩的节点个数,例如list-compress-depth为1，表示quickList的两端各有1个节点不进行压缩，中间结点开始进行压缩；</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">list-compress-depth 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三-hash" tabindex="-1"><a class="header-anchor" href="#三-hash"><span>三，Hash</span></a></h3><h4 id="_3-1-常用命令" tabindex="-1"><a class="header-anchor" href="#_3-1-常用命令"><span>3.1 常用命令</span></a></h4><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 插值：给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">fiel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 取值：从&lt;key&gt;集合&lt;field&gt;取出value</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hget</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">fiel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 批量插值：批量设置hash的值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hmset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">field</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">field</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">...</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 判断filed是否存在：查看哈希表 key 中，给定域 field 是否存在</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hexists</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">fiel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取一个hash类型的key中的所有的field和value</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hgetall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取所有的filed：列出该hash集合的所有field</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hkeys</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取所有的value：列出该hash集合的所有value</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hvals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 增量：为哈希表 key 中的域 field 的值加上步长</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hincrby</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">fiel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">步长</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 不存在，插值：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hsetnx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">fiel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_3-2-应用场景"><span>3.2 应用场景</span></a></h4><p>电商系统购物车数据存储，存储的结构为 用户ID为key，商品ID为field，商品数量为value。购物车商品数量+1使用<code>hincrby &lt;key&gt; &lt;field&gt; 步长</code>。</p><h4 id="_3-3-数据结构" tabindex="-1"><a class="header-anchor" href="#_3-3-数据结构"><span>3.3 数据结构</span></a></h4><p>当数据量比较小，或者单个元素比较小时，底层用ziplist存储，详情参考上方。</p><p>Hash 数据结构底层实现字典dict数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> dict {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\tdictType </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">type;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 类型函数，用于实现多态</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tvoid</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">privdata;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 私有数据，用于实现多态</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\tdictht </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ht</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // 哈希表，字典使用 ht[0] 作为哈希表，ht[1] 用于进行 rehash</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> rehashidx;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // rehash索引，当没有执行 rehash 时，其值为 -1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} dict;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哈希表数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> dictht {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\tdictEntry </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">**</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">table;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 哈希表数组，数组中的每个元素是一个单向链表</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tunsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> size;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 哈希表数组大小</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tunsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sizemask;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 哈希掩码，用于计算索引</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tunsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> used;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 已有节点数量</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} dictht;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哈希表节点数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> dictEntry {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tvoid*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> key;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 键</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tunion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 值，可以为指针、有符号长整，无符号长整，双精度浮点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\t\tvoid</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">val;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\t\tuint64_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> u64;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\t\tint64_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s64;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\t\tdouble</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> d;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\t} v;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tstruct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> dictEntry </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">next;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} dictEntry;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体存储结构：</p><figure><img src="http://img.zouyh.top/article-img/20240917135016196.png" alt="image-20230306162901314" tabindex="0" loading="lazy"><figcaption>image-20230306162901314</figcaption></figure><h5 id="_3-2-1-渐进式rehash" tabindex="-1"><a class="header-anchor" href="#_3-2-1-渐进式rehash"><span>3.2.1 渐进式rehash</span></a></h5><p>​ dict数据结构中哈希表定义了两个<code>dictht ht[2]</code>，之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要将哈希表 1中的所有值迁移到哈希表2中。</p><p>​ ①，rehash 的步骤：每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作之外，还会顺序将哈希表 1中索引位置上的所有 key-value 迁移到哈希表 2上；随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把哈希表 1的所有 key-value 迁移到哈希表2，从而完成rehash 操作，这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。<br> ​ ②，rehash 触发条件：rehash 的触发条件跟负载因子有关，负载因子 = hash表已保存的节点数量 / hash表大小</p><ul><li>当负载因子大于等于 1 时，Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作</li><li>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管Redis 有没有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作</li></ul><h3 id="四-set" tabindex="-1"><a class="header-anchor" href="#四-set"><span>四，Set</span></a></h3><h4 id="_4-1-常用命令" tabindex="-1"><a class="header-anchor" href="#_4-1-常用命令"><span>4.1 常用命令</span></a></h4><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 添加：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sadd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.....</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 取出该集合的所有值</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">smembers</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sismember</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回该集合的元素个数</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scard</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除集合中的元素</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">srem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.....</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 随机从该集合中取出n个值，取出的值会从集合中删除</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">spop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;n&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 随机从该集合中取出n个值，取出的值不会从集合中删除</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">srandmember</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;n&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 把集合中一个值从一个集合移动到另一个集合</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">smove</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">sourc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">destinatio</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">n&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回两个集合的交集元素</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sinter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回两个集合的并集元素</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sunion</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回两个集合的差集元素(key1中的，不包含key2中的)</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sdiff</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_4-2-应用场景"><span>4.2 应用场景</span></a></h4><ul><li>抽奖活动：一次抽奖多个用户，例如参与抽奖的用户有10个，一次抽取2个用户作为中奖用户，使用<code>smembers key</code>查看所有抽奖成员，使用<code>srandmember &lt;key&gt; &lt;n&gt;</code>抽取n个成员，如果多次抽奖，被开奖的用户不可再次参与，可以使用<code>srandmember &lt;key&gt; &lt;n&gt;</code>抽取成员作为开奖用户，同时会移除已开奖的用户。</li><li>朋友圈消息点赞成员列表：在微信朋友圈当我点赞朋友的一条消息时，会在下方显示点赞成员列表，这个列表只显示与我是好友点赞成员，不是好友则不显示。那么此时可以使用交集<code>sinter &lt;key1&gt; &lt;key2&gt;</code>查询</li><li>查询条件交集，例如电商系统购买电脑时配置选择，</li></ul><h4 id="_4-3-数据结构" tabindex="-1"><a class="header-anchor" href="#_4-3-数据结构"><span>4.3 数据结构</span></a></h4><p>​ 整数集合是 Set 对象的底层实现之一，当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现，整数集合数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> intset {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tuint32_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> encoding;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 编码方式，指示元素的实际类型</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tuint32_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> length;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 元素数量</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\tint8_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> contents</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 元素数组，元素实际类型可能为 int16_t,int32_t,int64_t,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} intset;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该数据结构有以下特征：</p><ul><li>有序：元素数组中的元素按照从小到大排列，使用二分查找时间复杂度为 <code>O(logN)</code></li><li>升级：当有新元素加入集合，且新元素比所有现有元素类型都长时，集合需要进行升级</li></ul><p>升级操作：</p><p>​ 整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p><p>​ 整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。</p><p>举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素：</p><img src="http://img.zouyh.top/article-img/20240917135015193.png" alt="image-20230306170045177" style="zoom:67%;"><p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素<br><img src="http://img.zouyh.top/article-img/20240917135012185.png" alt="image-20230306170258098" style="zoom:67%;"></p><p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p><img src="http://img.zouyh.top/article-img/20240917135016198.png" alt="315b8745582c4e108431324c0b364225" style="zoom:80%;"><p>整数集合升级的好处是节省内存资源，不支持降级操作，当两个条件任意满足时Set将用hashtable存储数据，不在使用整数集合：</p><ul><li>元素个数大于配置文件配置的数值512个字节时， <code>set-max-intset-entries 512</code>,</li><li>元素无法用整形表示</li></ul><h3 id="五-sortedset" tabindex="-1"><a class="header-anchor" href="#五-sortedset"><span>五，SortedSet</span></a></h3><h4 id="_5-1-常用命令" tabindex="-1"><a class="header-anchor" href="#_5-1-常用命令"><span>5.1 常用命令</span></a></h4><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 插值：将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zadd </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;key&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">score</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">score</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">....</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回有序集 key 中，下标在&lt;start&gt; &lt;stop&gt;之间的元素， start=0到stop=-1就是返回全部的元素，从小到大排列,带withscores，可以让分数一起和值返回到结果集。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zrange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">star</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">t&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">sto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  [withscores]  </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zrangebyscore</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> min</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [withscores] </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，改为从大到小排列。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zrevrangebyscore</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> max</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [withscores]   </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 增量：为键key为，值为value的 score加上increment的增量</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zincrby</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">incremen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">t&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除：删除该集合下，指定值的元素</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zrem </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;key&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 统计该集合，分数区间内的元素个数</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zcount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">mi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">n&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ma</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">x&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 排名：返回该值在集合中的排名，从0开始</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">zrank</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-2-应用场景" tabindex="-1"><a class="header-anchor" href="#_5-2-应用场景"><span>5.2 应用场景</span></a></h4><p>​ 体育赛事排行榜、新闻热度排行榜，热点排行榜。我们任意打开一个新闻网站，总有块区域显示排行前10的新闻，排行版一般都是根据点击数来排行的，这个点击数就可以使用<code>zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt; </code>指令来实现</p><h4 id="_5-3-数据结构" tabindex="-1"><a class="header-anchor" href="#_5-3-数据结构"><span>5.3 数据结构</span></a></h4><p>zset数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zset {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dict </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">dict;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 维护 member -&gt; score 的映射，查找给的成员的分值</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    zskiplist </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">zsl;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 按 score 大小保存了所有集合元素，支持范围操作</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} zset;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跳表zskiplist数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplist {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">header, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">tail;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> length;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 跳表的节点的个数（不包含头节点）</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> level;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 跳表的节点的最大高度（不包括头节点）</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} zskiplist;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节点数据结构：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    sds ele;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 该节点所存储的字符串值</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> score;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 该节点排序的分值</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">backward;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 当前节点最底层的前一个节点，头节点和第一个节点的backward指向NULL</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistLevel {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">forward;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向同一层的下一个节点，尾节点的forward指向NULL</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> span;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // forward指向的节点与本节点之间的节点的个数，span越大说明跳过的节点的个数越多</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } level</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} zskiplistNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>存储结构：</p><figure><img src="http://img.zouyh.top/article-img/20240917135016199.png" alt="image-20230307105530039" tabindex="0" loading="lazy"><figcaption>image-20230307105530039</figcaption></figure><p>查找和插入节点的方式：</p><ul><li>查找时候从记录的最高level查找，如果forward指向NULL就向下一层查询。</li><li>插入节点的高度是随机的，调用zslRandomLevel函数为节点随机生成高度。</li></ul><p>有序集合对象有2种编码方案，当同时满足以下条件时，集合对象采用ziplist编码，否则采用skiplist编码：</p><ul><li><code>zset-max-ziplist-value</code> ：当 member 的长度都小于该值时使用 ziplist 编码（默认为 64字节）</li><li><code>zset-max-ziplist-entries</code> ：当 zset 中的元素数量小于该值时使用 ziplist 编码（默认为 128个)</li></ul><h3 id="六-bitmaps" tabindex="-1"><a class="header-anchor" href="#六-bitmaps"><span>六，BitMaps</span></a></h3><h4 id="_6-1-常用命令" tabindex="-1"><a class="header-anchor" href="#_6-1-常用命令"><span>6.1 常用命令</span></a></h4><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 设置值 value：设置Bitmaps中某个偏移量的值（0或1）offset：偏移量，从0开始</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setbit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">offse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">t&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">valu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 取值 offset：偏移量，从0开始</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getbit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">offse</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">t&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 统计 统计字符串从start字节到end字节比特值为1的数量</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bitcount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; [start </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">end]</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#bitop是一个复合操作,它可以做多个Bitmaps的and(交集),or(并集),not(非),xor(异或) 操作并将结果保存在destkey中。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bitop </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (and/or/not/xor) &lt;destkey&gt; [key…]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-2-实现细节" tabindex="-1"><a class="header-anchor" href="#_6-2-实现细节"><span>6.2 实现细节</span></a></h4><p>​ 现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图：</p><figure><img src="http://img.zouyh.top/article-img/20240917135016197.png" alt="image-20230307110352968" tabindex="0" loading="lazy"><figcaption>image-20230307110352968</figcaption></figure><p>合理地使用操作位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据类型”可以实现对位的操作。</p><p>​ Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作，Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p><blockquote><p>Bitmaps经常用来统计较大用户的日活跃。</p></blockquote><h3 id="七-geospatial" tabindex="-1"><a class="header-anchor" href="#七-geospatial"><span>七，Geospatial</span></a></h3><h4 id="_7-1-常用命令" tabindex="-1"><a class="header-anchor" href="#_7-1-常用命令"><span>7.1 常用命令</span></a></h4><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 添加地理位置（经度，纬度，名称），两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入，已经添加的数据，是无法再次往里面添加的，有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">geoadd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">longitud</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">latitud</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">membe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r&gt; [longitude </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">latitude</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> member...] </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># geopos 获取某个元素的地理位置经纬度</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">geoadd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">membe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r&gt;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取两个位置之间的直线距离</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">geodist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">member</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">1&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">member</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">2&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  [m|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">km</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ft</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mi] </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 以给定的经纬度为中心，找出某一半径内的元素 </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">georadius</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">longitud</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">latitud</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">半径</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">km</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ft</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mi</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># georadiusbymember 跟 georadius 命令一样，都可以找出位于指定范围的位置元素，但是这里不是指定中心点坐标，而是指定以哪个元素为中心点。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">georadius</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">membe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">半径</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">km</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ft</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mi</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_7-2-实现细节" tabindex="-1"><a class="header-anchor" href="#_7-2-实现细节"><span>7.2 实现细节</span></a></h4><blockquote><p>geo 底层原理是使用跳表实现，分值是根据经纬度进行geohash的得到值。</p></blockquote><p>geohash 是 2008 年 Gustavo Niemeye 发明用来编码经纬度信息的一种编码方式，比如北京市中心的经纬度坐标是 116.404844,39.912279，通过 12 位 geohash 编码后就变成了 wx4g0cg3vknd，它究竟是如何实现的？其实原理非常简单，就是二分，整个编码过程可以分为如下几步：</p><p><strong>第一步：转二进制</strong></p><p>​ 上过初中地理的我们都知道，地球上任何一个点都可以标识为某个经纬度坐标，经度的取值范围是东经 0-180 度和西经 0-180 度，纬度的取值范围是北纬 0-90 和南纬 0-90 度。去掉东西南北，可以分别认为经度和纬度的取值范围为[-180,180]和[-90,90]。</p><img src="http://img.zouyh.top/article-img/20240917135014191.png" alt="image-20230307112411274" style="zoom:80%;"><p>我们先来看经度，[-180,180]可以简单分成两个部分[-180,0]和[0,180]，对于给定的一个具体值，我们用一个bit 来标识是在[-180,0]还是[0,180]区间里。然后我们可以对这两个子区间继续细分，用更多的 bit 来标识是这个值是在哪个子区间里。就好比用二分查找，记录下每次查找的路径，往左就是 0 往右是 1，查找完后我们就会得到一个 0101 的串，这个串就可以用来标识这个经度值。</p><figure><img src="http://img.zouyh.top/article-img/20240917135014192.png" alt="image-20230307112648832" tabindex="0" loading="lazy"><figcaption>image-20230307112648832</figcaption></figure><p>同理纬度也是一样，只不过他的取值返回变成了[-90,90]而已。通过这两种方式编码完成后，任意经纬度我们都可以得到两个由0和1组成的串。</p><figure><img src="http://img.zouyh.top/article-img/20240917135013186.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>第二步：经纬度二进制合并</strong></p><p>接下来我们只需要将上述二进制交错合并成一个即可，这里注意经度占偶数位，纬度占奇数位，得到最终的二进制</p><img src="http://img.zouyh.top/article-img/20240917135017200.png" alt="37c0b60c6dfbaf8bfecd34995f7c47ef" style="zoom:80%;"><p>1110011101001000111100000010110111100011</p><p><strong>第三步：将合并后的二进制做 base32 编码</strong></p><p>最后我们将合并后的二进制做 base32 编码，将连续 5 位转化为一个 0-31 的十进制数，然后用对应的字符代替，将所有二进制位处理完后我们就完成了 base32 编码。编码表如下：</p><img src="http://img.zouyh.top/article-img/20240917135013189.png" alt="image-20230307113028421" style="zoom:80%;"><p>最终得到 geohash 值。</p><h3 id="八-hyperloglog" tabindex="-1"><a class="header-anchor" href="#八-hyperloglog"><span>八，HyperLogLog</span></a></h3><h5 id="_8-1-简介" tabindex="-1"><a class="header-anchor" href="#_8-1-简介"><span>8.1 简介</span></a></h5><p>​ 在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p><p>解决基数问题有很多种方案：</p><ul><li>数据存储在MySQL表中，使用distinct count计算不重复个数</li><li>使用Redis提供的hash、set、bitmaps等数据结构来处理</li></ul><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p><p>​ Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>​ 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>​ 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h5 id="_8-2-常用命令" tabindex="-1"><a class="header-anchor" href="#_8-2-常用命令"><span>8.2 常用命令</span></a></h5><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 添加指定元素到 HyperLogLog中，将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pfadd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt;&lt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">elemen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">t&gt; [element </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">...]  </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pfcount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">ke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">y&gt; [key </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">...]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pfmerge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;destkey&gt;&lt;sourcekey&gt; [sourcekey </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',157)]))}]]),h=JSON.parse('{"path":"/blog/Redis/Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"Redis核心数据结构","lang":"zh-CN","frontmatter":{"icon":"file-lines","title":"Redis核心数据结构","author":"Ms.Zyh","date":"2024-04-10T00:00:00.000Z","category":["Redis"],"tag":["推荐","Redis"],"sticky":false,"star":false,"description":"数据类型和对应的数据结构： 一，String 1.1 常见命令 redis的键是String类型： redis的值是String类型： 1.2 应用场景 缓存对象：直接缓存整个对象的 JSON 或者 采用将 key 进行分离为 user:ID:属性 常规计数: Redis 处理命令是单线程，所以执行命令的过程是原子或者使用lua脚本执行多条命令也是原子...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis核心数据结构\\",\\"image\\":[\\"http://img.zouyh.top/article-img/20240917135015195.png\\",\\"http://img.zouyh.top/article-img/20240917135016196.png\\",\\"http://img.zouyh.top/article-img/20240917135016199.png\\",\\"http://img.zouyh.top/article-img/20240917135016197.png\\",\\"http://img.zouyh.top/article-img/20240917135014192.png\\",\\"http://img.zouyh.top/article-img/20240917135013186.png\\"],\\"datePublished\\":\\"2024-04-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-20T07:21:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ms.Zyh\\"}]}"],["meta",{"property":"og:url","content":"http://img.zouyh.top/blog/Redis/Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Mr.Zyh"}],["meta",{"property":"og:title","content":"Redis核心数据结构"}],["meta",{"property":"og:description","content":"数据类型和对应的数据结构： 一，String 1.1 常见命令 redis的键是String类型： redis的值是String类型： 1.2 应用场景 缓存对象：直接缓存整个对象的 JSON 或者 采用将 key 进行分离为 user:ID:属性 常规计数: Redis 处理命令是单线程，所以执行命令的过程是原子或者使用lua脚本执行多条命令也是原子..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://img.zouyh.top/article-img/20240917135015195.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-20T07:21:23.000Z"}],["meta",{"property":"article:author","content":"Ms.Zyh"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"推荐"}],["meta",{"property":"article:published_time","content":"2024-04-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-20T07:21:23.000Z"}]]},"git":{"createdTime":1755935409000,"updatedTime":1758352883000,"contributors":[{"name":"zyh1020","username":"zyh1020","email":"898362059@qq.pcom","commits":3,"url":"https://github.com/zyh1020"}]},"readingTime":{"minutes":23.88,"words":7163},"filePathRelative":"blog/Redis/Redis核心数据结构.md","excerpt":"<p>数据类型和对应的数据结构：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>数据类型</th>\\n<th>底层结构</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>String</td>\\n<td>SDS</td>\\n</tr>\\n<tr>\\n<td>List</td>\\n<td>双向列表，压缩列表</td>\\n</tr>\\n<tr>\\n<td>Hash</td>\\n<td>压缩列表，Hash表</td>\\n</tr>\\n<tr>\\n<td>Set</td>\\n<td>整数集合，Hash表</td>\\n</tr>\\n<tr>\\n<td>SortedSet</td>\\n<td>压缩列表，跳表</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}')}}]);