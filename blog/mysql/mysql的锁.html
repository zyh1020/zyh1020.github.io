<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.24" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.94" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"mysql的锁","image":["http://img.zouyh.top/article-img/20240917135003159.png","http://img.zouyh.top/article-img/20240917135003158.png","http://img.zouyh.top/article-img/20240917135002155.png","http://img.zouyh.top/article-img/20240917135003160.png","http://img.zouyh.top/article-img/20240917135002154.png","http://img.zouyh.top/article-img/20240917135000151.png","http://img.zouyh.top/article-img/20240917135002156.png","http://img.zouyh.top/article-img/20240917135002153.png","http://img.zouyh.top/article-img/20240917135003157.png","http://img.zouyh.top/article-img/20240917135000152.png"],"datePublished":"2022-04-27T00:00:00.000Z","dateModified":"2025-09-06T08:18:22.000Z","author":[{"@type":"Person","name":"Ms.Zyh"}]}</script><meta property="og:url" content="http://img.zouyh.top/vuepress/blog/mysql/mysql%E7%9A%84%E9%94%81.html"><meta property="og:site_name" content="Mr.Zyh"><meta property="og:title" content="mysql的锁"><meta property="og:description" content="一，锁的分类 ①，以锁粒度的维度划分： 表锁： 全局锁：加上全局锁之后，整个数据库只能允许读，不允许做任何写操作。 元数据锁 / MDL锁：基于表的元数据加锁，加锁后整张表不允许其他事务操作。 意向锁：这个是InnoDB中为了支持多粒度的锁，为了兼容行锁、表锁而设计的。 自增锁 / AUTO-INC锁：这个是为了提升自增ID的并发插入性能而设计的。 行..."><meta property="og:type" content="article"><meta property="og:image" content="http://img.zouyh.top/article-img/20240917135003159.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-09-06T08:18:22.000Z"><meta property="article:author" content="Ms.Zyh"><meta property="article:tag" content="mysql"><meta property="article:tag" content="偏僻"><meta property="article:published_time" content="2022-04-27T00:00:00.000Z"><meta property="article:modified_time" content="2025-09-06T08:18:22.000Z"><link rel="icon" href="http://zouyh.top/favicon.png"><title>mysql的锁 | Mr.Zyh</title><meta name="description" content="一，锁的分类 ①，以锁粒度的维度划分： 表锁： 全局锁：加上全局锁之后，整个数据库只能允许读，不允许做任何写操作。 元数据锁 / MDL锁：基于表的元数据加锁，加锁后整张表不允许其他事务操作。 意向锁：这个是InnoDB中为了支持多粒度的锁，为了兼容行锁、表锁而设计的。 自增锁 / AUTO-INC锁：这个是为了提升自增ID的并发插入性能而设计的。 行...">
    <link rel="stylesheet" href="/vuepress/assets/css/styles.e906e378.css">
    <link rel="preload" href="/vuepress/assets/js/runtime~app.60ce2f83.js" as="script"><link rel="preload" href="/vuepress/assets/css/styles.e906e378.css" as="style"><link rel="preload" href="/vuepress/assets/js/5967.2f754431.js" as="script"><link rel="preload" href="/vuepress/assets/js/app.d77a90c1.js" as="script">
    <link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_zookeeper源码解析.html.64dea8e4.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Spring_spring的AOP原理解析.html.7dc3542f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Spring_spring的IOC加载整体流程.html.1439cc75.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_结构模式-代理模式.html.714c4bd3.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_mybatis源码解析Mapp配置文件.html.a4ee15ed.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_mybatis源码解析核心配置文件.html.ff2dc7c5.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_mybatis源码解析sql执行.html.88009be6.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_RocketMQ核心操作.html.e9fc9d32.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_mybatis缓存.html.8409acf7.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Spring_spring的事务原理解析.html.104bb9af.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringMvc_springMvc源码解析.html.1bf0903b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_redis实现分布式锁.html.44def7ae.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_zookeeper实现分布式锁.html.dd8904f4.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot的run方法.html.0be9ca4d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_ReentrantLock原理解析.html.ae03795e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_spring整合mybatis源码解析.html.aab62ad9.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_手写zookeeper配置中心.html.1f479ece.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Dubbo_dubbo中的spi机制.html.6f12e297.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Spring_spring的循环依赖.html.5c63b173.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_RabbitMQ的各种队列.html.d9b7c06f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot事件监听.html.770ca541.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_nacos的服务治理.html.f847c41e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_QLExpress表达式.html.40590012.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_RabbitMQ六种工作模式.html.e9501b3b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_mybatis插件.html.2523ced9.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot自动装配原理.html.0bc4fdf6.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_Lambda和Stream.html.9eca621f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_ReentrantReadWriteLock原理.html.06be09fe.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工作流_flowable请假流程案例.html.0950d216.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_RabbitMQ消息的可靠传递.html.6a6e0c35.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot内嵌tomcat原理解析.html.3433ff14.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Dubbo_@DubboReference注解.html.337fe802.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_CAS和Atomic.html.fdacb10f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_手写zookeeper注册中心.html.a47b4818.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_线程池ThreadPoolExecutor.html.b17da62d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_jvm类加载机制.html.78cead5e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot外置tomcat原理解析.html.af4cc56f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Netty_BIO，NIO和AIO模型.html.5d418015.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_Redis核心数据结构.html.f10bac4b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_RabbitMQ整合Spring或SpringBoot.html.bed3ce00.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringMvc_SpringMvc使用Validation参数校验.html.9aecb829.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_Semaphore原理.html.5b60370f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_Mybatis动态数据源.html.fe6cf2ff.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_HashMap原理.html.b013b053.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_反射.html.f750ed74.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_OpenFeign.html.72690f93.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_创建模式-工厂模式.html.c886839f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_String字符串常量池.html.9f2fde91.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_Redis缓存设计.html.f66e2b31.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_java对象的拷贝.html.881b76a1.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_jvm对象的结构和创建.html.89c78c31.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_ConcurrentHashMap分段锁.html.3402edf3.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_结构模式-适配器模式.html.6f31a933.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_java异常.html.95cff4c4.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_zookeeper常用命令.html.69be617e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Spring_Spring的@Conditional注解.html.5ddf3c15.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_Redis主从，哨兵和集群模式.html.12bf077e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_Sentinel限流.html.b67116c7.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工作流_flowable 会签、转派、委派、加签.html.1368b145.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/8300.507decb8.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_线程基础.html.e72d8abc.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_Redis发布订阅，锁和事务.html.7771dbf8.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot注册Bean的6种方式.html.54af3b4d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_volatile的原理.html.44bae7e9.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_@SentinelResource注解.html.97a54b7d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_关系模式-责任链模式.html.a40292e1.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_mysql的锁.html.74cc942b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_创建模式-生成器模式.html.bd835d4a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_关系模式-策略模式.html.2ce1ae6c.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_jvm调优工具.html.e0af0511.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_MySQL的sql执行流程.html.f062a1c0.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_jvm垃圾收集器.html.ec00e757.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_mysql的索引.html.0e4935e3.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_浮点精度（float、double）运算不精确的原因.html.05716b9e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_CountDownLatch和CyclicBarrier.html.14912d85.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_创建模式-单例模式.html.4b8ceed2.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_SpringCloud项目创建.html.a7c45837.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_结构模式-装饰者模式.html.1551c1bc.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_JVM的垃圾回收机制.html.95127e39.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Nginx_一篇搞定nignx.html.a8b38cb5.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_RabbitMQ安装.html.bddcd944.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_Sentinel熔断.html.1f04935b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_JMM模型.html.b2b50b98.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工作流_SpringBoot整合flowable.html.2bcc9441.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_mysql的事务.html.7fc6d6bd.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_安装RocketMQ.html.67c5dd69.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_SpringBoot自定义starter.html.99e8201a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_MySQL的MVCC.html.78c5fcf2.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_nacos的安装.html.f9620cd6.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_Redis持久化.html.7ef7ee8f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_synchronized底层原理 .html.6e095d82.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_nacos快速开始.html.e21b959b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_java运算符优先级.html.ff672314.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Docker_安装nginx.html.4dd2d315.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_java访问权限修饰符.html.1178dac3.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_云服务器MySQL数据自动备份到七牛云.html.09d0d546.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_安装zookeeper.html.b08bbd55.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Docker_linux安装docker.html.c4529fd2.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_mysql的Buffer Pool.html.9cef4ece.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Nginx_SSL证书安装.html.cba72a68.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_NavicatPremium16的安装与激活.html.61c0ff89.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Docker_安装mysql单机版本.html.caf49b7a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_sentinel快速开始.html.587961c1.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_ssh服务登录linux.html.c26e083a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_Odsidian文本编辑器.html.55cbbcf5.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_Jmeter的安装使用.html.7ef29473.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_日志架构历史.html.4b13f6b0.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工作流_Flowable流程图.html.3ef6e359.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_图床神器PicGo_七牛云.html.9db74719.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_JVM运行时内存划分.html.8caaf66e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_xshell8安装.html.7580712a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_TCP三次握手.html.f3a8893d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_常见问题.html.e4be10d9.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_idea2024.1.7的下载和激活.html.4c49b2a7.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_index.html.5ca8a91b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/index.html.0df8171a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/intro.html.331682a3.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_设计模式_index.html.7475e48e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_设计模式_index.html.bd8df728.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_多线程_index.html.1dcab7d9.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_工作流_index.html.ff9853ce.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_工作流_index.html.06249df1.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_多线程_index.html.5d75ae46.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_springcloud_index.html.ea7c554c.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_springboot_index.html.fd07892a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_工具_index.html.03d78dc5.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_springcloud_index.html.224c45c4.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_springmvc_index.html.ed7d9ade.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_zookeeper_index.html.c7fa04d7.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_springboot_index.html.c63879f2.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_偏僻_index.html.26a3f51a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_基础_index.html.f28c3eb5.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_工具_index.html.c5171f35.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_必看_index.html.65195973.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_常用_index.html.e3c655db.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_干货_index.html.54241831.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_推荐_index.html.c863d18a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_进阶_index.html.4f25c8ec.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_springmvc_index.html.7e9a9f72.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_zookeeper_index.html.6fffec96.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_mybatis_index.html.a2c0c728.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_docker_index.html.ea2daa11.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_spring_index.html.020ccba4.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_设计模式_index.html.dbd347a7.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_mybatis_index.html.0770c906.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_dubbo_index.html.a9e48a1d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_mysql_index.html.bfcda2d7.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_netty_index.html.042bb132.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_nginx_index.html.57e79921.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_redis_index.html.c090a810.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_docker_index.html.9d12998e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_spring_index.html.762ef73d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/404.html.57fac949.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_java_index.html.f7270835.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_dubbo_index.html.61d1f7df.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_mysql_index.html.5bafde00.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_redis_index.html.5f915c28.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_netty_index.html.d0232965.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_nginx_index.html.177fd13a.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_jvm_index.html.9d84b417.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_java_index.html.855e1b27.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_mq_index.html.f17da645.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_多线程_index.html.78eeb90d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工作流_index.html.00cd55ac.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_jvm_index.html.6354515c.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_mq_index.html.0c9f2ea0.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/timeline_index.html.6a6748f0.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringCloud_index.html.9cd6eede.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringBoot_index.html.72282e6b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/category_index.html.2e11b212.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_工具_index.html.1cac8984.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_SpringMvc_index.html.a492930e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/article_index.html.d9e68ca1.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_zookeeper_index.html.526715d4.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/tag_index.html.f00b68bc.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/star_index.html.fc974875.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Mybatis_index.html.4a7162db.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Docker_index.html.d97d1b41.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Spring_index.html.e741c490.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Dubbo_index.html.ac7059df.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Netty_index.html.6b332e02.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Nginx_index.html.97e98841.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Redis_index.html.41eed3b0.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_mysql_index.html.4c47783f.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Java_index.html.857a99cb.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_Jvm_index.html.1822c4c2.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/blog_MQ_index.html.2b0b76b6.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar auto-hide" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/vuepress/" aria-label="带我回家"><!----><!----><span class="vp-site-name">Mr.Zyh</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/vuepress/" aria-label="主页"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" sizing="height" height="1em"></iconify-icon><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/vuepress/blog/" aria-label="文章"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:book-open" sizing="height" height="1em"></iconify-icon><!--]-->文章<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/vuepress/category/" aria-label="分类"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:bookmark" sizing="height" height="1em"></iconify-icon><!--]-->分类<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/vuepress/timeline/" aria-label="时间轴"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:calendar" sizing="height" height="1em"></iconify-icon><!--]-->时间轴<!----></a></div></nav><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><iconify-icon class="vp-icon" icon="fa6-solid:folder-open" sizing="both" width="1em" height="1em"></iconify-icon><span class="vp-sidebar-title">文章目录</span><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Docker</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Dubbo</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Jvm</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">MQ</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Mybatis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">Mysql</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress/blog/mysql/mysql%E7%9A%84Buffer%20Pool.html" aria-label="mysql的Buffer Pool"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->mysql的Buffer Pool<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress/blog/mysql/MySQL%E7%9A%84MVCC.html" aria-label="MySQL的MVCC"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->MySQL的MVCC<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress/blog/mysql/MySQL%E7%9A%84sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.html" aria-label="MySQL的sql执行流程"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->MySQL的sql执行流程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress/blog/mysql/mysql%E7%9A%84%E4%BA%8B%E5%8A%A1.html" aria-label="mysql的事务"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->mysql的事务<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress/blog/mysql/mysql%E7%9A%84%E7%B4%A2%E5%BC%95.html" aria-label="mysql的索引"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->mysql的索引<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/vuepress/blog/mysql/mysql%E7%9A%84%E9%94%81.html" aria-label="mysql的锁"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->mysql的锁<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/vuepress/blog/mysql/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8MySQL%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91.html" aria-label="云服务器MySQL数据自动备份到七牛云"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->云服务器MySQL数据自动备份到七牛云<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Netty</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Nginx</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Spring</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Spring Boot</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Spring Cloud</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Spring Mvc</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Zookeeper</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">多线程</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">工作流</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">工具</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">设计模式</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="height" height="1em"></iconify-icon>mysql的锁</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">Ms.Zyh</span></span><span property="author" content="Ms.Zyh"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2022/4/27</span><meta property="datePublished" content="2022-04-27T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 21 分钟</span><meta property="timeRequired" content="PT21M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color1 clickable" role="navigation">mysql</span><!--]--><meta property="articleSection" content="mysql"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color5 clickable" role="navigation">偏僻</span><span class="page-tag-item color1 clickable" role="navigation">mysql</span><!--]--><meta property="keywords" content="偏僻,mysql"></span></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h3 id="一-锁的分类" tabindex="-1"><a class="header-anchor" href="#一-锁的分类"><span>一，锁的分类</span></a></h3><p>①，以锁粒度的维度划分：</p><ul><li>表锁： <ul><li>全局锁：加上全局锁之后，整个数据库只能允许读，不允许做任何写操作。</li><li>元数据锁 / <code>MDL</code>锁：基于表的元数据加锁，加锁后整张表不允许其他事务操作。</li><li>意向锁：这个是<code>InnoDB</code>中为了支持多粒度的锁，为了兼容行锁、表锁而设计的。</li><li>自增锁 / <code>AUTO-INC</code>锁：这个是为了提升自增ID的并发插入性能而设计的。</li></ul></li><li>行锁： <ul><li>记录锁 / <code>Record</code>锁：也就是行锁，一条记录和一行数据是同一个意思。</li><li>间隙锁 / <code>Gap</code>锁：<code>InnoDB</code>中解决幻读问题的一种锁机制。</li><li>临键锁 / <code>Next-Key</code>锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能。</li><li>插入意向锁</li></ul></li><li>页面锁</li></ul><p>②，以互斥性的维度划分：</p><ul><li>共享锁 / <code>S</code>锁：不同事务之间不会相互排斥、可以同时获取的锁。</li><li>排他锁 / <code>X</code>锁：不同事务之间会相互排斥、同时只能允许一个事务获取的锁。</li><li>共享排他锁 / <code>SX</code>锁：<code>MySQL5.7</code>版本中新引入的锁，主要是解决<code>SMO</code>带来的问题。</li></ul><p>③，以操作类型的维度划分：</p><ul><li>读锁：查询数据时使用的锁。</li><li>写锁：执行插入、删除、修改、<code>DDL</code>语句时使用的锁。</li></ul><p>④，以加锁方式的维度划分：</p><ul><li>显示锁：编写<code>SQL</code>语句时，手动指定加锁的粒度。</li><li>隐式锁：执行<code>SQL</code>语句时，根据隔离级别自动为<code>SQL</code>操作加锁。</li></ul><p>⑤，以思想的维度划分：</p><ul><li>乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁。</li><li>悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行。</li></ul><p>​ 放眼望下来，是不是看着还蛮多的，但总归说来说去其实就共享锁、排他锁两种，只是加的方式不同，加的地方不同，因此就演化出了这么多锁的称呼</p><h3 id="二-共享锁和排他锁" tabindex="-1"><a class="header-anchor" href="#二-共享锁和排他锁"><span>二，共享锁和排他锁</span></a></h3><p>​ 有些地方也将共享锁称之为读锁，排他锁称之为写锁，但这个说法并不完全正确，因为同时发生读读操作时，这里的读操作表现是可以共享，但是同时发生读写操作时，这里的读操作表现可以是排他的，比如：一条线程在读数据时加了一把锁（读锁），此时当另外一条线程来尝试对相同数据做写操作时，这条线程会陷入阻塞，因为mysql中一条线程在读时不允许其他线程改。因此共享锁称之为读锁，排他锁称之为写锁这说法并不正确，<strong>共享锁就是共享锁，排他锁就是排他锁，不能与读锁、写锁混为一谈</strong></p><h4 id="_2-1-共享锁" tabindex="-1"><a class="header-anchor" href="#_2-1-共享锁"><span>2.1 共享锁</span></a></h4><p>​ 共享锁的意思很简单，也就是不同事务之间不会排斥，可以同时获取锁并执行，这就类似于之前聊过的，但这里所谓的不会排斥，仅仅只是指不会排斥其他事务来读数据，但其他事务尝试写数据时，就会出现排斥性。</p><p>在<code>MySQL</code>中，我们可以在<code>SQL</code>语句后加上相关的关键字来使用共享锁，语法如下:</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... LOCK </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE MODE;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- MySQL8.0之后也优化了写法，如下：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 这种通过在<code>SQL</code>后添加关键字的加锁形式，被称为显式锁，而实际上为数据库设置了不同的事务隔离级别后，<code>MySQL</code>也会对<code>SQL</code>自动加锁，这种形式则被称之为隐式锁。</p><p>举个例子理解共享锁：</p><p>打开两个<code>cmd</code>窗口并与<code>MySQL</code>建立连接，执行如下命令：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> share mode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://img.zouyh.top/article-img/20240917135003159.png" alt="image-20230202105310095" tabindex="0" loading="lazy"><figcaption>image-20230202105310095</figcaption></figure><p>此时两个事务都是执行查询的操作，可以正常执行。</p><p>紧接着再在白色窗口中，尝试修改ID=1的数据：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;小3&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="http://img.zouyh.top/article-img/20240917135003158.png" alt="image-20230202105726153" tabindex="0" loading="lazy"><figcaption>image-20230202105726153</figcaption></figure><p>一个事务尝试对具备共享锁的数据进行写操作时，会被共享锁排斥，共享锁表现出了排他性。</p><h4 id="_2-2-排他锁" tabindex="-1"><a class="header-anchor" href="#_2-2-排他锁"><span>2.2 排他锁</span></a></h4><p>​ 上面简单的了解了共享锁之后，紧着来看看排他锁，排他锁也被称之为独占锁。当一个线程获取到独占锁后，会排斥其他线程，如若其他线程也想对共享资源/同一数据进行操作，必须等到当前线程释放锁并竞争到锁资源才行。</p><p>在<code>MySQL</code>中，可以通过如下方式显式获取独占锁：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> UPTATE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>举个例子理解独占锁：</p><figure><img src="http://img.zouyh.top/article-img/20240917135002155.png" alt="image-20230202111115661" tabindex="0" loading="lazy"><figcaption>image-20230202111115661</figcaption></figure><p>当一个事务获取到排他锁，另一个事务也尝试获取排他锁，读取一条相同的数据时，就会陷入阻塞。</p><figure><img src="http://img.zouyh.top/article-img/20240917135003160.png" alt="image-20230202111357014" tabindex="0" loading="lazy"><figcaption>image-20230202111357014</figcaption></figure><p>当一个事务获取到排他锁，另一个事务尝试获取共享锁，读取一条相同的数据时，就也会陷入阻塞。</p><figure><img src="http://img.zouyh.top/article-img/20240917135002154.png" alt="image-20230202111514743" tabindex="0" loading="lazy"><figcaption>image-20230202111514743</figcaption></figure><p>当一个事务获取到排他锁，另一个事务不获锁读数据，而是以普通的方式读数据，这种方式则可以立刻执行，这是为什么呢？是因为读操作默认加共享锁吗？显然不是第二个例子证明尝试获取共享锁时，也会陷入阻塞，究竟是因为啥原因才导致的能读到数据，其实这跟另一种并发控制技术有关，即<code>MVCC</code>机制。</p><p>​ 在前面的实验中，每次都仅获取了锁，但好像从未释放过锁呀？其实<code>MySQL</code>中释放锁的动作都是隐式的，毕竟如果交给咱们来释放，很容易由于操作不当造成死锁问题发生，在不同的隔离级别中也并不相同，比如在“读未提交”级别中，是<code>SQL</code>执行完成后就立马释放锁，而在“可重复读”级别中，是在事务结束后才会释放。</p><h4 id="_2-3-共享排他锁" tabindex="-1"><a class="header-anchor" href="#_2-3-共享排他锁"><span>2.3 共享排他锁</span></a></h4><p>​ <code>MySQL5.7.2</code>版本中引入了一种新的锁，被称之为<code>(SX)</code>共享排他锁，这种锁是共享锁与排他锁的杂交类型，至于为何引入这种锁呢？聊它之前需要先理解<code>SMO</code>问题</p><p>​ 在<code>SQL</code>执行期间一旦更新操作触发<code>B+Tree</code>叶子节点分裂，那么就会对整棵<code>B+Tree</code>加排它锁，这不但阻塞了后续这张表上的所有的更新操作，同时也阻止了所有试图在<code>B+Tree</code>上的读操作，也就是会导致所有的读写操作都被阻塞，其影响巨大。因此，这种大粒度的排它锁成为了<code>InnoDB</code>支持高并发访问的主要瓶颈，而这也是<code>MySQL 5.7</code>版本中引入<code>SX</code>锁要解决的问题。</p><p>​ 那想一下该如何解决这个问题呢？最简单的方式就是减小<code>SMO</code>问题发生时，锁定的<code>B+Tree</code>粒度优化，当发生<code>SMO</code>问题时，就只锁定<code>B+Tree</code>的某个分支，而并不是锁定整颗<code>B+</code>树，从而做到不影响其他分支上的读写操作。</p><p>在聊之前首先得搞清楚<code>SQL</code>执行时的几个概念：</p><ul><li>读取操作：基于<code>B+Tree</code>去读取某条或多条行记录。</li><li>乐观写入：不会改变<code>B+Tree</code>的索引键，仅会更改索引值，比如主键索引树中不修改主键字段，只修改其他字段的数据，不会引起节点分裂。</li><li>悲观写入：会改变<code>B+Tree</code>的结构，也就是会造成节点分裂，比如无序插入、修改索引键的字段值。</li></ul><p>​ 上述讲到的三种执行情况，对于读操作、乐观写入操作而言，并不会加<code>SX</code>锁，共享排他锁仅针对于悲观写入操作会加，由于读操作、乐观写入执行前对整颗树加的是<code>S</code>锁，因此悲观写入时加的<code>SX</code>锁并不会阻塞乐观写入和读操作，但当另一个事务尝试执行<code>SMO</code>操作变更树结构时，也需要先对树加上一个<code>SX</code>锁，这时两个悲观写入的并发事务就会出现冲突，新来的事务会被阻塞。</p><h3 id="三-表锁" tabindex="-1"><a class="header-anchor" href="#三-表锁"><span>三，表锁</span></a></h3><p>​ 表锁应该是听的最多的一种锁，因为实现起来比较简单，同时应用范围也比较广泛，几乎所有的存储引擎都会支持这个粒度的锁，比如常用的<code>MyISAM、InnoDB、Memory</code>等各大引擎都实现了表锁，但要注意，不同引擎的表锁也在实现上以及加锁方式上有些许不同，但归根结底，表锁的意思也就以表作为锁的基础，将锁加在表上，一张表只能存在一个同一类型的表锁。</p><p>​ 比如<code>InnoDB</code>是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当<code>SQL</code>执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁，比如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>select * from user for update;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这条<code>SQL</code>就无法命中聚簇索引，此时自然加的就是表级别的排他锁，但是这个表级锁，并不是真正意义上的表锁，是一个“伪表锁”，但作用是相同的，锁了整张表.</p><p>而反观<code>MyISAM</code>引擎，由于它并不支持聚簇索引，所以无法再以<code>InnoDB</code>的这种形式去对表上锁，因此如若要在<code>MyISAM</code>引擎中使用表锁，又需要使用额外的语法，如下:</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- MyISAM引擎中获取读锁（具备读-读可共享特性）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">LOCK TABLES </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">`table_name`</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> READ</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- MyISAM引擎中获取写锁（具备写-读、写-写排他特性）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">LOCK TABLES </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">`table_name`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> WRITE;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查看目前库中创建过的表锁（in_use&gt;0表示目前正在使用的表锁）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SHOW </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">OPEN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TABLES </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> in_use </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 释放已获取到的锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UNLOCK</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TABLES</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例理解MyISAM的表锁：</p><p>①，读读：不阻塞</p><figure><img src="http://img.zouyh.top/article-img/20240917135000151.png" alt="image-20230202114833339" tabindex="0" loading="lazy"><figcaption>image-20230202114833339</figcaption></figure><p>②，读写：阻塞</p><figure><img src="http://img.zouyh.top/article-img/20240917135002156.png" alt="image-20230202114637988" tabindex="0" loading="lazy"><figcaption>image-20230202114637988</figcaption></figure><p>③，写读：阻塞</p><figure><img src="http://img.zouyh.top/article-img/20240917135002153.png" alt="image-20230202115006636" tabindex="0" loading="lazy"><figcaption>image-20230202115006636</figcaption></figure><p>④，写写：阻塞</p><figure><img src="http://img.zouyh.top/article-img/20240917135003157.png" alt="image-20230202115231240" tabindex="0" loading="lazy"><figcaption>image-20230202115231240</figcaption></figure><p>​ MyISAM引擎中，获取了锁还需要自己手动释放锁，否则会造成死锁现象出现，因为如果不手动释放锁，就算事务结束也不会自动释放，除非当前的数据库连接中断时才会释放。如下：</p><figure><img src="http://img.zouyh.top/article-img/20240917135000152.png" alt="image-20230202113306388" tabindex="0" loading="lazy"><figcaption>image-20230202113306388</figcaption></figure><h4 id="_3-1-元数据锁" tabindex="-1"><a class="header-anchor" href="#_3-1-元数据锁"><span>3.1 元数据锁</span></a></h4><p>​ <code>Meta Data Lock</code>元数据锁，也被简称为<code>MDL</code>锁，这是基于表的元数据加锁，想要搞懂元数据锁，首先要知道元数据是什么？</p><p>所有存储引擎的表都会存在一个<code>.frm</code>文件，这个文件中主要存储表的结构，而<code>MDL</code>锁就是基于<code>.frm</code>文件中的元数据加锁的。</p><p>​ 对于这种锁是在<code>MySQL5.5</code>版本后再开始支持的，一般来说咱们用不上，因此也无需手动获取锁，这个锁主要是用于：更改表结构时使用，比如你要向一张表创建/删除一个索引、修改一个字段的名称/数据类型、增加/删除一个表字段等这类情况。</p><p>​ 毕竟当你的表结构正在发生更改，假设此时有其他事务来对表做<code>CRUD</code>操作，自然就会出现问题，比如我刚删了一个表字段，结果另一个事务中又按原本的表结构插入了一条数据，这显然会存在风险，因此<code>MDL</code>锁在加锁后，整张表不允许其他事务做任何操作。</p><h4 id="_3-2-意向锁" tabindex="-1"><a class="header-anchor" href="#_3-2-意向锁"><span>3.2 意向锁</span></a></h4><p>​ <code>InnoDB</code>引擎是一种支持多粒度锁的引擎，而意向锁则是为了实现<code>InnoDB</code>支持多粒度，兼容行锁、表锁而设计的锁。</p><p>怎么理解这句话呢？先来看一个例子：</p><p>​ 假设一张表中有千万条数据，现在事务<code>T1</code>对<code>ID=800W</code>的这条数据加了一个行锁，此时来了一个事务<code>T2</code>，想要获取这张表的表级别写锁，经过前面的一系列讲解，大家应该知道写锁必须为排他锁，也就是在同一时刻内，只允许当前事务操作，如果表中存在其他事务已经获取了锁，目前事务就无法满足“独占性”，因此不能获取锁。</p><p>​ 那思考一下，由于<code>T1</code>是对<code>ID=800W</code>的数据加了行锁，那<code>T2</code>获取表锁时，是不是得先判断一下表中是否存在其他事务在操作？但因为<code>InnoDB</code>中有行锁的概念，所以表中任何一行数据上都有可能存在事务加锁操作，为了能精准的知道答案，<code>MySQL</code>就得将整张表的<code>1000W</code>条数据全部遍历一次，然后逐条查看是否有锁存在，那这个效率自然会非常的低。</p><p>​ 有人可能会说，慢就慢点怎么了，能接受！但实际上不仅仅存在这个问题，还有另外一个致命问题，比如现在<code>MySQL</code>已经判断到了第<code>500W</code>行数据，发现前面的数据上都没有锁存在，正在继续往下遍历，万一又来了一个事务在扫描过的数据行上加了个锁怎么办？比如在第<code>100W</code>条数据上加了一个行锁。那难道又重新扫描一遍嘛？这就陷入了死循环，行锁和表锁之间出现了兼容问题。</p><p>​ 也正是由于行锁和表锁之间存在兼容性问题，所以意向锁它来了！意向锁实际上也是一种特殊的表锁，意向锁其实是一种“挂牌告知”的思想，好比日常生活中的出租车，一般都会有一个牌子，表示它目前是“空车”还是“载客”状态，而意向锁也是这个思想。</p><p>​ 比如<code>T1</code>要对<code>ID=800W</code>的数据加一个行级别的读锁，就会先添加一个表级别的意向共享锁，如果<code>T1</code>要加行级别的写锁，亦是同理。</p><p>这个时候<code>T2</code>要获取的表级别的锁，就不需要判断每一条数据有没有加锁了。</p><h4 id="_3-3-自增锁" tabindex="-1"><a class="header-anchor" href="#_3-3-自增锁"><span>3.3 自增锁</span></a></h4><p>​ 自增锁，这个是专门为了提升自增ID的并发插入性能而设计的，通常情况下咱们在建表时，都会对一张表的主键设置自增特性，如下：</p><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-mysql"><span class="line"><span>CREATE TABLE `table_name` (</span></span>
<span class="line"><span>    `xx_id` NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>    .....</span></span>
<span class="line"><span>) ENGINE = InnoDB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 当对一个字段设置<code>AUTO_INCREMENT</code>自增后，意味着后续插入数据时无需为其赋值，系统会自动赋上顺序自增的值。但想一想，比如目前表中最大的<code>ID=88</code>，如果两个并发事务一起对表执行插入语句，由于是并发执行的原因，所以有可能会导致插入两条<code>ID=89</code>的数据。因此这里必须要加上一个排他锁，确保并发插入时的安全性，但也由于锁的原因，插入的效率也就因此降低了，毕竟将所有写操作串行化了。</p><p>​ 为了改善插入数据时的性能，自增锁诞生了，自增锁也是一种特殊的表锁，但它仅为具备<code>AUTO_INCREMENT</code>自增字段的表服务，同时自增锁也分成了不同的级别，可以通过<code>innodb_autoinc_lock_mode</code>参数控制。</p><ul><li><code>innodb_autoinc_lock_mode = 0</code>：传统模式。</li><li><code>innodb_autoinc_lock_mode = 1</code>：连续模式（<code>MySQL8.0</code>以前的默认模式）。</li><li><code>innodb_autoinc_lock_mode = 2</code>：交错模式（<code>MySQL8.0</code>之后的默认模式）。</li></ul><p>​ 简单了解上述三种插入模式后，再用一句话来概述自增锁的作用：自增锁主要负责维护并发事务下自增列的顺序，也就是说，每当一个事务想向表中插入数据时，都要先获取自增锁先分配一个自增的顺序值，但不同模式下的自增锁也会有些许不同。</p><h4 id="_3-4-全局锁" tabindex="-1"><a class="header-anchor" href="#_3-4-全局锁"><span>3.4 全局锁</span></a></h4><p>​ 全局锁其实是一种尤为特殊的表锁，其实将它称之为库锁也许更合适，因为全局锁是基于整个数据库来加锁的，加上全局锁之后，整个数据库只能允许读，不允许做任何写操作，一般全局锁是在对整库做数据备份时使用。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 获取全局锁的命令</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">FLUSH TABLES </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WITH</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> READ</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LOCK;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 释放全局锁的命令</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UNLOCK</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TABLES;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述的命令也可以看出，为何将其归纳到表锁范围，因为获取锁以及释放锁的命令都是表锁的命令。</p><h3 id="四-行锁" tabindex="-1"><a class="header-anchor" href="#四-行锁"><span>四，行锁</span></a></h3><p>​ 在<code>MySQL</code>诸多的存储引擎中，仅有<code>InnoDB</code>引擎支持行锁，这是由于什么原因导致的呢？因为<code>InnoDB</code>支持聚簇索引，<code>InnoDB</code>中如果能够命中索引数据，就会加行锁，无法命中则会加表锁。<code>InnoDB</code>会将表数据存储在聚簇索引中，每条行数据都会存储在树中的叶子节点上，因此行数据是“分开的”，所以可以对每一条数据上锁，但其他引擎大部分都不支持聚簇索引，表数据都是一起存储在一块的，所以只能基于整个表数据上锁，这也是为什么其他引擎不支持行锁的原因。</p><h4 id="_4-1-记录锁" tabindex="-1"><a class="header-anchor" href="#_4-1-记录锁"><span>4.1 记录锁</span></a></h4><p><code>Record Lock</code>记录锁，实际上就是行锁，一行表数据、一条表记录本身就是同一个含义，因此行锁也被称为记录锁。使用方式如下：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 获取行级别的 共享锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tablename </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> userId </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> share mode;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 获取行级别的 排他锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tablename </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> userId </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要使用<code>InnoDB</code>的行锁就是这样写的，如果你的<code>SQL</code>能命中索引数据，那也就自然加的就是行锁，反之则是表锁.</p><h4 id="_4-2-间隙锁" tabindex="-1"><a class="header-anchor" href="#_4-2-间隙锁"><span>4..2 间隙锁</span></a></h4><p>间隙锁是对行锁的一种补充，主要是用来解决幻读问题的，但想要理解它，咱们首先来理解啥叫间隙：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>SELECT * FROM user;</span></span>
<span class="line"><span>+---------+-----------+</span></span>
<span class="line"><span>| user_id | user_name |</span></span>
<span class="line"><span>+---------+-----------+</span></span>
<span class="line"><span>|       1 | 小1       |</span></span>
<span class="line"><span>|       2 | 小2       | </span></span>
<span class="line"><span>|       3 | 小3       | </span></span>
<span class="line"><span>|       4 | 小4       | </span></span>
<span class="line"><span>|       9 | 小9       | </span></span>
<span class="line"><span>+---------+-----------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述这张表最后两条数据，<code>ID</code>字段之间从<code>4</code>跳到了<code>9</code>，那么<code>4~9</code>两者之间的范围则被称为“间隙”，而间隙锁则主要锁定的是这块范围。</p><p>那为何又说间隙锁是用来解决幻读问题的呢？</p><p>​ 因为幻读的概念是：一个事务在执行时，另一个事务插入了一条数据，从而导致第一个事务操作完成之后发现结果与预想的不一致，跟产生了幻觉一样。</p><p>​ 举例子，现在要将<code>ID&gt;3</code>的用户名重置为<code>小x</code>，因此事务<code>T1</code>先查到了<code>ID&gt;3</code>的<code>4、9</code>两条数据并上锁了，然后开始更改用户名，但此时事务<code>T2</code>过来又插入了一条<code>ID=6、userName=小6</code>的数据并提交，等<code>T1</code>修改完了<code>4、9</code>两条数据后，此时再次查询<code>ID&gt;3</code>的数据时，结果发现了<code>ID=6</code>的这条数据并未被重置用户名。</p><p>​ 在上述这个例子中，<code>T2</code>因为新增并提交了事务，所以<code>T1</code>再次查询时也能看到<code>ID=6</code>的这条数据，就跟产生了幻觉似的，对于这种新增数据，专业的叫法称之为幻影数据。</p><p>​ 为了防止出现安全问题，所以<code>T1</code>在操作之前会对目标数据加锁，但在<code>T1</code>事务执行时，这条幻影数据还不存在，因此就会出现一个新的问题：不知道把锁加在哪儿，毕竟想要对<code>ID=6</code>的数据加锁，就是加了个寂寞。</p><p>​ 那难道不加锁了吗？肯定得加锁，但怎么加呢？普通的行锁就已经无法解决这个问题了，总不能加表锁吧，那也太影响性能了，所以间隙锁应运而生！间隙锁的功能与它的名字一样，主要是对间隙区域加锁，举个例子：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> share mode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>​ 这条加锁的<code>SQL</code>看起来似乎不是那么合理对吧？毕竟<code>ID=6</code>的数据在表中还没有呀，咋加锁呢？其实这个就是间隙锁，此时会锁定<code>{4~9}</code>之间、但不包含<code>4、9</code>的区域，因为间隙锁是遵循<strong>左右开区间</strong>的原则</p><p>​ 简单说一下结论：当对一个不存在的数据加锁后，默认就是锁定前后两条数据之间的区间，当其他事务再尝试向该区间插入数据时，就会陷入阻塞，只有当持有间隙锁的事务结束后，才能继续执行插入操作。</p><p>​ 间隙锁加在不同的位置，锁定的范围也并不相同，如果加在两条数据之间，那么锁定的区域就是两条数据之间的间隙。如果加在上表<code>ID=1</code>的数据上，锁定的区域就是<code>{-∞ ~ 1}</code>，即无穷小到<code>1</code>之间的区域。如果加在<code>ID=9</code>之后，锁定的区域就是<code>{9 ~ +∞}</code>，即<code>9</code>之后到无穷大的区域。</p><h4 id="_4-3-临键锁" tabindex="-1"><a class="header-anchor" href="#_4-3-临键锁"><span>4..3 临键锁</span></a></h4><p>临键锁是间隙锁的<code>Plus</code>版本，或者可以说成是一种由记录锁+间隙锁组成的锁：</p><ul><li>记录锁：锁定的范围是表中具体的一条行数据。</li><li>间隙锁：锁定的范围是左闭右开的区间，并不包含最后一条真实数据。</li></ul><p>而临键锁则是两者的结合体，加锁后，即锁定左闭右开的区间，也会锁定当前行数据。</p><p>举个例子：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> share mode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>​ 事务<code>T1</code>基于表中<code>ID=9</code>的这条数据加锁的，此时来看结果，除开锁定了<code>4~9</code>这个区间外，对于<code>ID=9</code>这条数据也锁定了，在事务<code>T2</code>中尝试对<code>ID=9</code>的数据修改时，也会让事务陷入阻塞。</p><blockquote><p>临键锁的注意点：当原本持有锁的<code>T1</code>事务结束后，<code>T2</code>会执行插入操作，这时锁会被<code>T2</code>获取，当你开启一个新的事务<code>T3</code>，再次尝试获取相同的临键锁时，是无法获取的，只能等<code>T2</code>结束后才能获取，因为临建锁包含了记录锁，虽然间隙锁可以同时由多个事务持有，但排他类型的记录锁只允许一个事务持有。</p></blockquote><h4 id="_4-4-插入意向锁" tabindex="-1"><a class="header-anchor" href="#_4-4-插入意向锁"><span>4.4 插入意向锁</span></a></h4><p>​ 插入意向锁，听起来似乎跟前面的表级别意向锁有些类似，但实际上插入意向锁是一种间隙锁，这种锁是一种隐式锁，也就是咱们无法手动的获取这种锁。通常在<code>MySQL</code>中插入数据时，是并不会产生锁的，但在插入前会先简单的判断一下，当前事务要插入的位置有没有存在间隙锁或临键锁，如果存在的话，当前插入数据的事务则需阻塞等待，直到拥有临键锁的事务提交</p><p>​ 当持有原本持有临建锁的事务提交后，当前事务即可以获取插入意向锁，然后执行插入操作，当此时如若又来一个新的事务，也要在该区间中插入数据，那新的事务会阻塞吗？答案是不会，可以直接执行插入操作，为什么？</p><p>​ 简单来说就是：能够真正执行的插入语句，绝对是通过了唯一检测的，因此插入时可以让多事务并发执行，同时如果设置了自增<code>ID</code>，也会获取自增锁确保安全性，所以当多个事务要向一个区间插入数据时，插入意向锁是不会排斥其他事务的，从这种角度而言，插入意向锁也是一种共享锁。</p><h3 id="五-页面锁" tabindex="-1"><a class="header-anchor" href="#五-页面锁"><span>五，页面锁</span></a></h3><p>​ 页面锁是<code>Berkeley DB</code>存储引擎支持的一种锁粒度，当然，由于<code>BDB</code>引擎被<code>Oracle</code>收购的原因，因此<code>MySQL5.1</code>以后不再直接性的支持该引擎。</p><p>参考链接：<a href="https://juejin.cn/post/7153869469394305061" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7153869469394305061</a></p></div><!----><!----><!----></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新</span><time class="vp-meta-info" datetime="2025-09-06T08:18:22.000Z" data-allow-mismatch>2025/9/6 08:18</time></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 898362059@qq.pcom">zyh1020</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/vuepress/blog/mysql/mysql%E7%9A%84%E7%B4%A2%E5%BC%95.html" aria-label="mysql的索引"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="height" height="1em"></iconify-icon>mysql的索引</div></a><a class="route-link auto-link next" href="/vuepress/blog/mysql/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8MySQL%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91.html" aria-label="云服务器MySQL数据自动备份到七牛云"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">云服务器MySQL数据自动备份到七牛云<iconify-icon class="vp-icon" icon="fa6-solid:file-lines" sizing="height" height="1em"></iconify-icon></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">豫ICP备2022026603号</div><div class="vp-copyright">Copyright © 2025 Ms.Zyh </div></footer></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script src="/vuepress/assets/js/runtime~app.60ce2f83.js" defer></script><script src="/vuepress/assets/js/5967.2f754431.js" defer></script><script src="/vuepress/assets/js/app.d77a90c1.js" defer></script>
  </body>
</html>
