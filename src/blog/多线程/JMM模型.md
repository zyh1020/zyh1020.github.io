---
icon: file-lines
title: JMM模型
author: Ms.Zyh
date: 2022-06-13
category:
  - 多线程
tag:
  - 常用
  - 多线程
sticky: false
star: false
---

### 一，JMM模型

#### 1.1 介绍

​	Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。每个JVM 的实现都要遵守JMM规范，JMM规范的保障了并发程序运行在不同的虚拟机上时，得到的程序结果是安全可靠的。如果没有JMM内存模型来规范，就可能会出现，经过不同 JVM 翻译之后，运行的结果不相同也不正确的情况。	

#### 1.2 主内存和工作内存

​	java运行时内存模型JVM运行程序的实体是线程，在每个线程创建时，JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据。Java 内存模型JMM规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行。工作内存是线程私有，所以不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。

![image-20230213111756130](http://img.zouyh.top/article-img/20240917135046283.png)

​	主内存主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常 量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。

​	工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)， 每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。

根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式：

- 实例对象中的成员方法：
  - 如果方法中包含本地变量是基本数据类型(boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构。
  - 如果方法中包含本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域堆)中。
  
- 实例对象的成员变量：不管它是基本数据 类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。

- static变量以及类本身相关信息将会存储在主内存中。

#### 1.3 数据同步八大原子操作

​	不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，具体流程是首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存。

​	假设主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作， A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案 是，不确定，B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后， B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？

<img src="http://img.zouyh.top/article-img/20240917135046284.png" alt="image-20230213114549592" style="zoom:50%;" />



一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

- lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态 
- unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后 的变量才可以被其他线程锁定 
- read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存 中，以便随后的load动作使用 
- load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工 作内存的变量副本中 
- use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 
- assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 
- store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 
- write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

![image-20230214100257930](http://img.zouyh.top/article-img/20240917135047286.png)

同步规则分析 ：

- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主存中 
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化 （load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行 assign和load操作
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock 和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个 变量之前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去 unlock一个被其他线程锁定的变量
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write 操作）

> 注意：Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。

#### 1.4 指令重排

​	java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义是什么？JVM能根据处理器特性（CPU多级缓存系统、多核处 理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序，重排序分三种类型：

![image-20230214104140269](http://img.zouyh.top/article-img/20240917135046285.png)

- 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序：现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

**as-if-serial语义**

​	as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。

​	为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序， 因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可 能被编译器和处理器重排序。

```java
double pi  = 3.14;    //A  
double r   = 1.0;     //B  
double area = pi * r * r; //C  
```

​	A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系，因此在最终执行的指令序列中，C不能被重排序到A和B的前面，如果C排到A和B的前面，程序的结果将会被改变，但是A和B之间是没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。

#### 1.5 JMM的三大特性

##### 1.5.1 原子性

①，定义：

​	原子性指的是一个操作是不可分割，不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。

②，解析：

```java
int i = 2;
int j = i;
i++;
i = i + 1;
```

​	第一句是基本类型赋值操作，必定是原子性操作。

​	第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。

​	第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。

​	在java中，对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于32位系统的来说，long类型数据和double类型数据，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因 为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元， 这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取 到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能 是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为 读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数 据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。

③，解决方式:

​	 JMM只能保证八大原子操作的原子性，如果要保证一个代码块的原子性，可以通过 synchronized和 Lock实现原子性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。

##### 1.5.2 可见性

①，定义：

​	可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。

②，解析：

​	对于串行程序来说，可见性是不存在的， 因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且 是修改过的新值， 但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。

③，解决方式:

​	volatile关键字保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即 被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个 线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中

##### 1.5.3 有序性

①，定义：

​	有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这 样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺 序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟 现象。

②，解析：

​	一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。

③，解决方式:

​	在Java里面，可以通过volatile关键字来保证一定的“有序性,，另外可以通过synchronized和Lock来保证有序性，很显然， synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

#### 1.6 happens-before 原则

​	只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从JDK 5开始，Java使用新的JSR-133内存模型，提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：

1. 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。 
2. 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
3. volatile规则volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
4. 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见 
5. 传递性 A先于B ，B先于C 那么A必然先于C 
6. 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。 
7. 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
8.  对象终结规则对象的构造函数执行，结束先于finalize()方法
