---
icon: file-lines
# 标题
title: '关系模式-责任链模式'
# 设置作者
author: Ms.Zyh
# 设置写作时间
date: 2022-04-13
# 一个页面可以有多个分类
category:
  - 设计模式
# 一个页面可以有多个标签
tag:
  - 必看
  - 设计模式
# 此页面会在文章列表置顶
sticky: false
# 此页面会出现在星标文章中
star: false
---

> 如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止.

模式结构成员构成：
- 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
- 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
- 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

UML图：
![image.png](http://img.zouyh.top/article-img/20240917135143400.png)
抽象处理者：
```java
public abstract class Handler {
    // 能处理的最大天数
    private int maxDay;
    // 下一个处理
    private Handler nextHandler;

    public Handler(int maxDay, Handler nextHandler) {
        this.maxDay = maxDay;
        this.nextHandler = nextHandler;
    }

    protected abstract void handleLeave(LeaveRequest leave);
    //提交请假条
    public final void submit(LeaveRequest leave){
        // 自己能处理
        if(leave.getNum() <  this.maxDay){
            this.handleLeave(leave);
        }else if(this.nextHandler != null){
            // 提交给上级领导进行审批
            this.nextHandler.submit(leave);
        }else {
            System.out.println("流程结束");
        }
    }

}
```
具体处理者：
```java
public class GroupLeader extends Handler{
    public GroupLeader(int maxDay, Handler nextHandler) {
        super(maxDay, nextHandler);
    }
    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println("======"+leave.getName()+"提交了，"+leave.getNum()+"天的假期======");
        System.out.println("组长-审批："+leave.getNum()+"假期！");
    }
}

public class Manager extends Handler{
    public Manager(int maxDay, Handler nextHandler) {
        super(maxDay, nextHandler);
    }
    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println("======"+leave.getName()+"提交了，"+leave.getNum()+"天的假期======");
        System.out.println("经理-审批："+leave.getNum()+"假期！");
    }
}
public class GeneralManager extends Handler{
    public GeneralManager(int maxDay, Handler nextHandler) {
        super(maxDay, nextHandler);
    }

    @Override
    protected void handleLeave(LeaveRequest leave) {
        System.out.println("======"+leave.getName()+"提交了，"+leave.getNum()+"天的假期======");
        System.out.println("总经理-审批："+leave.getNum()+"假期！");
    }
}

```
客户端：
```java
public class LeaveRequest {
    // 请假人
    private String name;
    // 请假天数
    private int num;
    // 备注
    private String content;
    public LeaveRequest(String name, int num, String content) {
        this.name = name;
        this.num = num;
        this.content = content;
    }
    public int getNum() {
        return num;
    }
    public String getName() {
        return name;
    }
}

public class Client {
    public static void main(String[] args) {
        Handler generalManager = new GeneralManager(360,null);
        Handler manager = new Manager(30,generalManager);
        Handler groupLeader = new GroupLeader(7,manager);

        LeaveRequest leaveRequest= new LeaveRequest("zyh",1,"");
        groupLeader.submit(leaveRequest);
        LeaveRequest leaveRequest2= new LeaveRequest("zyh",15,"");
        groupLeader.submit(leaveRequest2);
        LeaveRequest leaveRequest3= new LeaveRequest("zyh",60,"");
        groupLeader.submit(leaveRequest3);
        LeaveRequest leaveRequest4= new LeaveRequest("zyh",460,"");
        groupLeader.submit(leaveRequest4);
    }
}
```
结果：
```
======zyh提交了，1天的假期======
组长-审批：1假期！
======zyh提交了，15天的假期======
经理-审批：15假期！
======zyh提交了，60天的假期======
总经理-审批：60假期！
流程结束
```
责任链模式的优缺点：
- 优点：责任明确，只需要关注自己的责任，降低对象之间的耦合度。
- 缺点：职责链的长度和程序的复杂度。


责任链模式的经典场景：
- Web开发中的Filter过滤器
- Spring MVC中的拦截器HandlerInterceptor。
- mybatis的plugin插件。
