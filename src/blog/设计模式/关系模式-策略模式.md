---
icon: file-lines
# 标题
title: '关系模式-策略模式'
# 设置作者
author: Ms.Zyh
# 设置写作时间
date: 2022-05-24
# 一个页面可以有多个分类
category:
  - 设计模式
# 一个页面可以有多个标签
tag:
  - 基础
  - 设计模式
# 此页面会在文章列表置顶
sticky: false
# 此页面会出现在星标文章中
star: false
---

### 一，策略模式
> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

模式结构成员构成：
- 环境角色(Context)：持有一个策略类的引用，提供给客户端使用。
- 抽象策略角色(Strategy)：这是一个抽象角色，通常由一个接口或抽象类实现。
- 具体策略角色(ConcreteStrategy)：包装了相关的算法或行为

UML图：
![image.png](http://img.zouyh.top/article-img/20240917135142399.png)
案例：
抽象角色：
```java
public interface Strategy {
    int calc(int num1,int num2);
}
```
具体角色：
```java
public class OperationAdd  implements Strategy {
    @Override
    public int calc(int num1, int num2) {
        return num1 + num2;
    }
}

public class OperationSub  implements Strategy{
    @Override
    public int calc(int num1, int num2) {
        return num1 - num2;
    }
}

public class OperationMul implements Strategy{
    @Override
    public int calc(int num1, int num2) {
        return num1 * num2;
    }
}

public class OperationDiv  implements Strategy{
    @Override
    public int calc(int num1, int num2) {
        return num1 / num2;
    }
}

```
环境：
```java
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    public int executeStrategy(int num1, int num2) {
        return strategy.calc(num1, num2);
    }
}

```
测试：
```java
public class Test {
    public static void main(String[] args) {
        Context context = new Context(new OperationAdd());
        int i = context.executeStrategy(1, 2);
        System.out.println("i:"+i);
        Context context2 = new Context(new OperationSub());
        int i2 = context2.executeStrategy(1, 2);
        System.out.println("i2:"+i2);
        Context context3 = new Context(new OperationDiv());
        int i3 = context3.executeStrategy(1, 2);
        System.out.println("i3:"+i3);
        Context context4 = new Context(new OperationMul());
        int i4 = context4.executeStrategy(1, 2);
        System.out.println("i4:"+i4);
    }
}
```
结果：
```
i:3
i2:-1
i3:0
i4:2
```
策略模式的优缺点：
- 优点：扩展性好，灵活性好，可以在不修改对象结构的情况下，为新的算法进行添加新的类进行实现
- 缺点：使用策略类变多，会增加系统的复杂度。

SpringBoot中使用策略模式更加方便
抽象策略角色：
```java
public interface Strategy {
    int calc(int num1,int num2);
}
```
具体策略角色：
```java
@Service
public class OperationAdd  implements Strategy {
    @Override
    public int calc(int num1, int num2) {
        return num1 + num2;
    }
}
@Service
public class OperationSub  implements Strategy{
    @Override
    public int calc(int num1, int num2) {
        return num1 - num2;
    }
}
@Service
public class OperationMul implements Strategy{
    @Override
    public int calc(int num1, int num2) {
        return num1 * num2;
    }
}
@Service
public class OperationDiv  implements Strategy{
    @Override
    public int calc(int num1, int num2) {
        return num1 / num2;
    }
}
```
环境角色：
```java
@Resource
private Map<String,Strategy> strategys;
```
使用的时候 @Autowired 或者 @Resource 即可，SpringBoot会帮我们把实现类自动注入注入Map，这样就可以直接使用了很方便。
