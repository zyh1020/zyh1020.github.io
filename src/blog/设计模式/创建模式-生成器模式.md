---
icon: file-lines
# 标题
title: '创建模式-生成器模式'
# 设置作者
author: Ms.Zyh
# 设置写作时间
date: 2022-05-10
# 一个页面可以有多个分类
category:
  - 设计模式
# 一个页面可以有多个标签
tag:
  - 常用
  - 设计模式
# 此页面会在文章列表置顶
sticky: false
# 此页面会出现在星标文章中
star: false
---

### 一，生成器模式
> 生成器模式（Builder）是一种创建型设计模式，这种模式的核心思想是将对象的构建过程拆分成多个步骤，每个步骤由一个独立的构建器对象负责，最终组合成一个完整的对象。

模式结构成员构成：
- Product：产品，想要生产的对象。
- Builder：生成器，抽象的生成，主要包含构建步骤。
- ConcreteBuilder：具体生成器，具体的构建步骤的实现
- Director：导演，指挥构建过程的顺序。

UMl图：
![image.png](http://img.zouyh.top/article-img/20240917135127392.png)
举例子：一个简单的例子，我们需要创建一个文档对象，它可能包括标题、正文、图像等部分。我们可以创建HTML文档也可以创建XML文档
示例代码
产品角色：
```java
public class Product {
    private String head;
    private String content;
    private String tail;
    public void printingName(){
        System.out.println("我是产品");
    }

    public void setHead(String head) {
        this.head = head;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public void setTail(String tail) {
        this.tail = tail;
    }
}
```
生成器：
```java
public abstract class Bulider {
    abstract Product getProduct();
    abstract void bulidHead(String head);
    abstract void bulidContent(String content);
    abstract void bulidTail(String tail);
}
```
具体生成器：
```java
public class HTMLBulider extends Bulider{
    private Product product = new Product();
    @Override
    Product getProduct() {
        return product;
    }

    @Override
    void bulidHead(String head) {
        System.out.println("设置HTML头部格式");
        product.setHead(head);
    }

    @Override
    void bulidContent(String content) {
        System.out.println("设置HTML内容格式");
        product.setContent(content);
    }

    @Override
    void bulidTail(String tail) {
        System.out.println("设置HTML尾部格式");
        product.setTail(tail);
    }
}
public class XMLBulider extends Bulider{
    private Product product = new Product();
    @Override
    Product getProduct() {
        return product;
    }

    @Override
    void bulidHead(String head) {
        System.out.println("设置XML格式头部");
        product.setHead(head);
    }

    @Override
    void bulidContent(String content) {
        System.out.println("设置XML格式内容");
        product.setContent(content);
    }

    @Override
    void bulidTail(String tail) {
        System.out.println("设置XML格式尾部");
        product.setTail(tail);
    }
}

```
导演：
```java
public class Director {
    private Bulider bulider;

    public Director(Bulider bulider) {
        this.bulider = bulider;
    }
    public Product bulidProduct(String head,String content,String tail){
        System.out.println("======开始======");
        bulider.bulidHead(head);
        bulider.bulidContent(content);
        bulider.bulidTail(tail);
        System.out.println("======结束======");
        return bulider.getProduct();
    }
}
```
测试
```java
public class Test {
    public static void main(String[] args) {
        HTMLBulider htmlBulider = new HTMLBulider();
        Director htmlDirector = new Director(htmlBulider);
        Product htmlProduct = htmlDirector.bulidProduct("头部", "内容", "尾部");
        XMLBulider xmlBulider = new XMLBulider();
        Director xmlDirector = new Director(xmlBulider);
        Product xmlProduct = xmlDirector.bulidProduct("头部", "内容", "尾部");
    }
}
```
结果：
```
======开始======
设置HTML头部格式
设置HTML内容格式
设置HTML尾部格式
======结束======
======开始======
设置XML格式头部
设置XML格式内容
设置XML格式尾部
======结束======
```

应用场景
- 创建复杂对象：当需要创建的对象具有复杂的构建过程，包含多个部分，每个部分可能有不同的配置选项时，生成器模式非常有用。它可以将对象的构建步骤分解为多个方法，使得构建过程更加清晰和可维护。
- 避免构造函数参数列表过长：如果一个类的构造函数需要大量的参数，使用构造函数传递所有参数会导致代码难以理解和维护。生成器模式允许通过链式调用方法来设置参数，使得代码更加清晰。
- 多种表示形式：当需要为同一对象创建不同的表示形式时，生成器模式非常有用。例如，可以使用不同的生成器创建 HTML、JSON 或 XML 文档。
- 产品变化不频繁：如果产品的部分结构相对稳定，但不同配置选项多种多样，生成器模式可以使得构建过程复用，只需改变具体生成器的配置即可。
- 
实际已有场景
- StringBuilder 类：StringBuilder 类是 Java 标准库中的一个典型的生成器模式的应用。它用于构建字符串对象，允许你通过链式调用方法来构建字符串。
- Hibernate ORM：Hibernate 是一个流行的 Java 持久化框架，它使用生成器模式来构建查询语句。它的 Criteria API 允许你通过方法链式调用来构建数据库查询条件，而不是手动编写 SQL 语句。
- Spring Framework：Spring 中的许多配置类也使用了生成器模式的概念。例如，`org.springframework.context.annotation.BeanDefinitionBuilder `类允许你以编程方式构建 Bean 定义。这在编写自定义的 Spring 注解处理器时非常有用。
- RestTemplate：Spring 的 RestTemplate 类可以用于发送 HTTP 请求，并且允许你以链式方式设置请求参数、请求头等信息，以构建 HTTP 请求
