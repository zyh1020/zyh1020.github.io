---
icon: file-lines
# 标题
title: '结构模式-适配器模式'
# 设置作者
author: Ms.Zyh
# 设置写作时间
date: 2022-04-20
# 一个页面可以有多个分类
category:
  - 设计模式
# 一个页面可以有多个标签
tag:
  - 偏僻
  - 设计模式
# 此页面会在文章列表置顶
sticky: false
# 此页面会出现在星标文章中
star: false
---

### 一，适配器模式
> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题

模式结构成员构成：
- 目标角色：期望实现的目标，一般是接口。
- 源角色：存在于系统中，是指内容满足客户需求，但是接口不匹配，需要转换
- 适配器：将源角色转换为目标角色
#### 1，类的适配器模式
案例：小明以前买了一个小米手机，送了一个小米充电器，现在只是找到了小米手机，小米充电器丢了，但是找了一个苹果充电器，小明为了充电，买了一个适配器。
UML图：
![image.png](http://img.zouyh.top/article-img/20240917135141398.png)
源角色：
```java
public interface TypeCCharge {
    int typeCCharge();
}
public class AppleTypeCCharger implements TypeCCharge{
    @Override
    public int typeCCharge() {
        System.out.println("苹果手机TypeC充电器----充电200V");
        return 200;
    }
}


```
目标角色：
```java
public interface AndroidCharge {
    int androidCharge();
}
``
适配器
```java
public class AndroidHandlerAdapter extends AppleTypeCCharger implements AndroidCharge{
    private TypeCCharge typeCCharge = new AppleTypeCCharger();
    @Override
    public int androidCharge() {
        int type = super.typeCCharge();
        System.out.println("适配器转换将typeC的200v的转换为安卓的50v");
        return type/4;
    }
}
```
测试
```java
// 客户端
public class XiaoMiPhone {
    private AndroidCharge androidCharge;

    public XiaoMiPhone(AndroidCharge androidCharge) {
        this.androidCharge = androidCharge;
    }
    public void charge(){
        int i = this.androidCharge.androidCharge();
        if(i == 50){
            System.out.println("充电成功");
        }else {
            System.out.println("充电失败");
        }

    }
}
// 测试
public class TestMain {
    public static void main(String[] args) {
        AndroidCharge androidCharge = new AndroidHandlerAdapter();
        XiaoMiPhone xiaoMiPhone = new XiaoMiPhone(androidCharge);
        xiaoMiPhone.charge();
    }
}

```
结果：
```
苹果苹果手机TypeC充电器----充电200V
适配器转换将typeC的200v的转换为安卓的50v
充电成功
```
#### 2，对象适配器
UML图：
![image.png](http://img.zouyh.top/article-img/20240917135137397.png)
源角色：
```java
public interface TypeCCharge {
    int typeCCharge();
}
public class AppleTypeCCharger implements TypeCCharge{
    @Override
    public int typeCCharge() {
        System.out.println("苹果手机TypeC充电器----充电200V");
        return 200;
    }
}
```
目标角色：
```java
public interface AndroidCharge {
    int androidCharge();
}
```
适配器：
```java
public class AndroidHandlerAdapter implements AndroidCharge{
    private TypeCCharge typeCCharge = new AppleTypeCCharger();
    @Override
    public int androidCharge() {
        int type = typeCCharge.typeCCharge();
        System.out.println("适配器转换将typeC的200v的转换为安卓的50v");
        return type/4;
    }
}

```
测试
```java
// 客户端
public class XiaoMiPhone {
    private AndroidCharge androidCharge;

    public XiaoMiPhone(AndroidCharge androidCharge) {
        this.androidCharge = androidCharge;
    }
    public void charge(){
        int i = this.androidCharge.androidCharge();
        if(i == 50){
            System.out.println("充电成功");
        }else {
            System.out.println("充电失败");
        }

    }
}
// 测试
public class TestMain {
    public static void main(String[] args) {
        AndroidCharge androidCharge = new AndroidHandlerAdapter();
        XiaoMiPhone xiaoMiPhone = new XiaoMiPhone(androidCharge);
        xiaoMiPhone.charge();
    }
}

```
结果：
```
苹果苹果手机TypeC充电器----充电200V
适配器转换将typeC的200v的转换为安卓的50v
充电成功
```
#### 3，接口适配器
UML图：
![image.png](http://img.zouyh.top/article-img/20240917135134396.png)
源角色：
```java
public interface TypeCCharge {
    int typeCCharge();
}
public class AppleTypeCCharger implements TypeCCharge{
    @Override
    public int typeCCharge() {
        System.out.println("苹果手机TypeC充电器----充电200V");
        return 200;
    }
}
```
目标角色：
```java
public interface AndroidCharge {
    int androidCharge();
}
```
适配器
```java
// 抽象适配器
public abstract class AndroidHandlerAdapter implements AndroidCharge{

    private TypeCCharge typeCCharge = new AppleTypeCCharger();
    @Override
    public int androidCharge() {
        int type = typeCCharge.typeCCharge();
        System.out.println("适配器转换将typeC的200v的转换为安卓的50v");
        return type/4;
    }
    @Override
    public void m2() {
    }
    @Override
    public String m3() {
        return null;
    }
}
// 适配器
public class AndroidHandlerAdapterImpl extends AndroidHandlerAdapter{
    @Override
    public int androidCharge() {
        return super.androidCharge();
    }
}

```
测试
```java
// 客户端
public class XiaoMiPhone {
    private AndroidCharge androidCharge;

    public XiaoMiPhone(AndroidCharge androidCharge) {
        this.androidCharge = androidCharge;
    }
    public void charge(){
        int i = this.androidCharge.androidCharge();
        if(i == 50){
            System.out.println("充电成功");
        }else {
            System.out.println("充电失败");
        }

    }
}
// 测试
public class TestMain {
    public static void main(String[] args) {
        AndroidCharge androidCharge = new AndroidHandlerAdapterImpl();
        XiaoMiPhone xiaoMiPhone = new XiaoMiPhone(androidCharge);
        xiaoMiPhone.charge();
    }
}

```
结果：
```
苹果苹果手机TypeC充电器----充电200V
适配器转换将typeC的200v的转换为安卓的50v
充电成功
```
三种适配器模式的应用场景区别：
- 类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承源类，实现新的接口即可。
- 对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有源类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
- 接口适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。

三种适配器模式的应用区别：
- 类适配器，以类给到适配器，将源类作为父类，继承，
- 对象适配器，以对象给到适配器里，将源对象作为成员变量，持有。
- 接口适配器，以抽象类给到适配器里，将源对象作为成员变量，持有。


#### 4，经典应用场景
springmvc的处理器适配器，Spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的 Adapter,其Handler与 HandlerAdapter 对应关系如下：
| Handler | 对应适配器 | 描述 |
|  -  |  -  | - |
| Controller | SimpleControllerHandlerAdapter | 标准控制器，返回ModelAndView||
HttpRequestHandler | HttpRequestHandlerAdapter | 业务自行处理 请求，不需要通过 modelAndView 转到视图|
|Servlet | SimpleServletHandlerAdapter | 基于标准的servlet 处理|
|HandlerMethod | RequestMappingHandlerAdapter | 基于@requestMapping对应方法处理|

